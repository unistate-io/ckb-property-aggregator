"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.injectCapacityAndPayFee = exports.payFeeByOutput = exports.payFee = exports.calculateFeeByTransactionSkeleton = exports.calculateFeeByTransaction = exports.calculateFee = exports.getMinFeeRate = void 0;
const common_scripts_1 = require("@ckb-lumos/common-scripts");
const lumos_1 = require("@ckb-lumos/lumos");
const config_1 = require("../config");
const capacity_1 = require("./capacity");
const transaction_1 = require("./transaction");
/**
 * Get minimal acceptable fee rate from RPC.
 */
async function getMinFeeRate(rpc) {
    rpc = typeof rpc === 'string' ? new lumos_1.RPC(rpc) : rpc;
    const info = await rpc.txPoolInfo();
    return lumos_1.BI.from(info.minFeeRate);
}
exports.getMinFeeRate = getMinFeeRate;
/**
 * Calculate transaction fee by transaction size and feeRate.
 */
function calculateFee(size, feeRate) {
    const ratio = lumos_1.BI.from(1000);
    const base = lumos_1.BI.from(size).mul(feeRate);
    const fee = base.div(ratio);
    if (fee.mul(ratio).lt(base)) {
        return fee.add(1);
    }
    return lumos_1.BI.from(fee);
}
exports.calculateFee = calculateFee;
/**
 * Calculate transaction fee by Transaction and a specific feeRate.
 */
function calculateFeeByTransaction(tx, feeRate) {
    const size = (0, transaction_1.getTransactionSize)(tx);
    return calculateFee(size, feeRate);
}
exports.calculateFeeByTransaction = calculateFeeByTransaction;
/**
 * Calculate transaction fee by TransactionSkeleton and a specific feeRate.
 */
function calculateFeeByTransactionSkeleton(txSkeleton, feeRate) {
    const tx = lumos_1.helpers.createTransactionFromSkeleton(txSkeleton);
    return calculateFeeByTransaction(tx, feeRate);
}
exports.calculateFeeByTransactionSkeleton = calculateFeeByTransactionSkeleton;
/**
 * Pay fee by minimal acceptable fee rate from the RPC,
 * of pay fee by a manual fee rate.
 */
async function payFee(props) {
    // Env
    const config = props.config ?? (0, config_1.getSporeConfig)();
    const feeRate = props.feeRate ?? (await getMinFeeRate(config.ckbNodeUrl));
    // Use lumos common script to pay fee
    return await common_scripts_1.common.payFeeByFeeRate(props.txSkeleton, props.fromInfos, feeRate, void 0, {
        useLocktimeCellsFirst: props.useLocktimeCellsFirst,
        enableDeductCapacity: props.enableDeductCapacity,
        config: config.lumos,
    });
}
exports.payFee = payFee;
/**
 * Specify an output to pay transaction fee.
 */
async function payFeeByOutput(props) {
    // Env
    const config = props.config ?? (0, config_1.getSporeConfig)();
    const feeRate = props.feeRate ?? (await getMinFeeRate(config.ckbNodeUrl));
    // Get TransactionSkeleton
    let txSkeleton = props.txSkeleton;
    // Get target output cell
    let outputs = txSkeleton.get('outputs');
    const output = outputs.get(props.outputIndex);
    if (!output) {
        throw new Error(`Cannot pay fee by Transaction.outputs[${props.outputIndex}] because it does not exist`);
    }
    // Check can pay fee with capacity margin
    const minimalCellCapacity = lumos_1.helpers.minimalCellCapacityCompatible(output);
    const outputCapacity = lumos_1.BI.from(output.cellOutput.capacity);
    const capacityMargin = outputCapacity.sub(minimalCellCapacity);
    const fee = calculateFeeByTransactionSkeleton(txSkeleton, feeRate);
    if (capacityMargin.lt(fee)) {
        throw new Error(`Cannot pay fee by Transaction.outputs[${props.outputIndex}] due to insufficient capacity`);
    }
    // Pay fee and update capacity
    output.cellOutput.capacity = outputCapacity.sub(fee).toHexString();
    outputs = outputs.set(props.outputIndex, output);
    return txSkeleton.set('outputs', outputs);
}
exports.payFeeByOutput = payFeeByOutput;
/**
 * Inject needed amount of capacity,
 * and then pay fee by minimal acceptable fee rate or by a manual fee rate.
 */
async function injectCapacityAndPayFee(props) {
    // Env
    const config = props.config ?? (0, config_1.getSporeConfig)();
    // Collect capacity
    const injectNeededCapacityResult = await (0, capacity_1.injectNeededCapacity)({
        ...props,
        config: config.lumos,
    });
    // Pay fee
    const txSkeleton = await payFee({
        ...props,
        txSkeleton: injectNeededCapacityResult.txSkeleton,
    });
    return {
        txSkeleton,
        before: injectNeededCapacityResult.before,
        after: (0, capacity_1.createCapacitySnapshot)(txSkeleton.get('inputs').toArray(), txSkeleton.get('outputs').toArray()),
    };
}
exports.injectCapacityAndPayFee = injectCapacityAndPayFee;
//# sourceMappingURL=fee.js.map