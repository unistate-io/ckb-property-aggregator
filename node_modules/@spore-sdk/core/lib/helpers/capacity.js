"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.injectNeededCapacity = exports.calculateNeededCapacity = exports.correctChangeCellCapacity = exports.createCapacitySnapshot = exports.getCellsTotalCapacity = exports.setAbsoluteCapacityMargin = exports.getCellCapacityMargin = exports.assetCellMinimalCapacity = exports.correctCellMinimalCapacity = exports.minimalCellCapacityByLock = void 0;
const cloneDeep_1 = __importDefault(require("lodash/cloneDeep"));
const lumos_1 = require("@ckb-lumos/lumos");
const common_scripts_1 = require("@ckb-lumos/common-scripts");
/**
 * Calculate target cell's minimal occupied capacity by lock script.
 */
function minimalCellCapacityByLock(lock) {
    return lumos_1.helpers.minimalCellCapacityCompatible({
        cellOutput: {
            capacity: '0x0',
            lock,
        },
        data: '0x',
    });
}
exports.minimalCellCapacityByLock = minimalCellCapacityByLock;
/**
 * Fix cell's minimal occupied capacity by 'helpers.minimalCellCapacityCompatible' API.

 * Note: this function will modify the original cell object.
 */
function correctCellMinimalCapacity(cell) {
    const occupiedCapacity = lumos_1.helpers.minimalCellCapacityCompatible(cell);
    if (!occupiedCapacity.eq(cell.cellOutput.capacity)) {
        cell.cellOutput.capacity = occupiedCapacity.toHexString();
    }
    return cell;
}
exports.correctCellMinimalCapacity = correctCellMinimalCapacity;
/**
 * Make sure the target cell has declared enough amount of capacity.
 */
function assetCellMinimalCapacity(cell) {
    const minimalCapacity = lumos_1.helpers.minimalCellCapacityCompatible(cell);
    if (minimalCapacity.gt(cell.cellOutput.capacity)) {
        const minimal = minimalCapacity.toString();
        const declared = lumos_1.BI.from(cell.cellOutput.capacity).toString();
        throw new Error(`Target cell required capacity of ${minimal}, but declared ${declared}`);
    }
}
exports.assetCellMinimalCapacity = assetCellMinimalCapacity;
/**
 * Calculate the target cell's capacity margin.
 * Could be negative if the cell's declared capacity is not enough.
 */
function getCellCapacityMargin(cell) {
    const minimalCapacity = lumos_1.helpers.minimalCellCapacityCompatible(cell);
    return lumos_1.BI.from(cell.cellOutput.capacity).sub(minimalCapacity);
}
exports.getCellCapacityMargin = getCellCapacityMargin;
/**
 * Set absolute capacity margin for a cell.
 * The term 'absolute' means the cell's capacity will be: 'minimal capacity' + 'capacity margin'.
 */
function setAbsoluteCapacityMargin(cell, capacityMargin) {
    cell = (0, cloneDeep_1.default)(cell);
    const currentMargin = getCellCapacityMargin(cell);
    const margin = capacityMargin instanceof Function ? capacityMargin(cell, currentMargin) : capacityMargin;
    const minimalCapacity = lumos_1.helpers.minimalCellCapacityCompatible(cell);
    cell.cellOutput.capacity = minimalCapacity.add(margin).toHexString();
    return cell;
}
exports.setAbsoluteCapacityMargin = setAbsoluteCapacityMargin;
/**
 * Count the total containing capacity of a cells list.
 */
function getCellsTotalCapacity(cells) {
    return cells.reduce((sum, cell) => sum.add(cell.cellOutput.capacity), lumos_1.BI.from(0));
}
exports.getCellsTotalCapacity = getCellsTotalCapacity;
/**
 * Calculate the summary of capacity/length difference between inputs and outputs.
 */
function createCapacitySnapshot(inputs, outputs) {
    const inputsCapacity = getCellsTotalCapacity(inputs);
    const outputsCapacity = getCellsTotalCapacity(outputs);
    const inputsRemainCapacity = inputsCapacity.sub(outputsCapacity);
    const outputsRemainCapacity = outputsCapacity.sub(inputsCapacity);
    return {
        inputsLength: inputs.length,
        outputsLength: outputs.length,
        inputsCapacity,
        outputsCapacity,
        inputsRemainCapacity,
        outputsRemainCapacity,
    };
}
exports.createCapacitySnapshot = createCapacitySnapshot;
/**
 * Calculates the capacity different in Transaction.inputs and Transaction.outputs,
 * then fix the change cell's containing capacity if inputs' total capacity has any left.
 *
 * Note: normally the change cell is the last cell in Transaction.outputs,
 * but if things are different you can also provide the change cell's output index.
 */
function correctChangeCellCapacity(props) {
    let txSkeleton = props.txSkeleton;
    const inputs = txSkeleton.get('inputs').toArray();
    const outputs = txSkeleton.get('outputs').toArray();
    const snapshot = createCapacitySnapshot(inputs, outputs);
    if (snapshot.inputsRemainCapacity.gt(0)) {
        const outputIndex = props.changeOutputIndex ?? txSkeleton.get('outputs').size - 1;
        txSkeleton = txSkeleton.update('outputs', (outputs) => {
            const output = outputs.get(outputIndex);
            if (!output) {
                throw new Error('Cannot correct change cell capacity because Transaction.outputs is empty');
            }
            const oldCapacity = lumos_1.BI.from(output.cellOutput.capacity);
            output.cellOutput.capacity = oldCapacity.add(snapshot.inputsRemainCapacity).toHexString();
            return outputs;
        });
    }
    return txSkeleton;
}
exports.correctChangeCellCapacity = correctChangeCellCapacity;
/**
 * Calculate the capacity difference between Transaction.inputs and Transaction.outputs,
 * and see how much capacity is needed for the transaction to be constructed.
 */
function calculateNeededCapacity(props) {
    let txSkeleton = props.txSkeleton;
    // Get snapshot of inputs/outputs
    const inputs = txSkeleton.get('inputs').toArray();
    const outputs = txSkeleton.get('outputs').toArray();
    const snapshot = createCapacitySnapshot(inputs, outputs);
    // If not specified a fee, will collect 1 CKB by default
    const estimatedFee = lumos_1.BI.from(props.fee ?? '100000000');
    let neededCapacity = snapshot.outputsRemainCapacity.add(estimatedFee);
    // Calculate remain capacity
    const remainCapacity = snapshot.inputsRemainCapacity;
    const fromInfo = (0, common_scripts_1.parseFromInfo)(props.fromInfo, { config: props.config });
    const minimalChangeCapacity = minimalCellCapacityByLock(fromInfo.fromScript).add(estimatedFee);
    if (neededCapacity.lte(0) && remainCapacity.gt(0) && remainCapacity.lt(minimalChangeCapacity)) {
        neededCapacity = minimalChangeCapacity;
    }
    return {
        snapshot,
        estimatedFee,
        neededCapacity,
        remainCapacity,
    };
}
exports.calculateNeededCapacity = calculateNeededCapacity;
/**
 * Calculate the minimal required capacity for the transaction to be constructed,
 * and then collect ckb cells to inputs, it also fills cellDeps and witnesses.
 * After collecting, it will generate an output to return unused ckb.
 *
 * Note: The function also collects for estimated transaction fee.
 */
async function injectNeededCapacity(props) {
    let txSkeleton = props.txSkeleton;
    const changeInfo = props.changeAddress ?? props.fromInfos[0];
    const calculated = calculateNeededCapacity({
        txSkeleton,
        fee: props.fee,
        config: props.config,
        fromInfo: changeInfo,
    });
    const before = calculated.snapshot;
    let after;
    // collect needed capacity
    if (calculated.neededCapacity.gt(0)) {
        txSkeleton = await common_scripts_1.common.injectCapacity(txSkeleton, props.fromInfos, calculated.neededCapacity, props.changeAddress, void 0, {
            enableDeductCapacity: props.enableDeductCapacity,
            config: props.config,
        });
        const inputs = txSkeleton.get('inputs').toArray();
        const outputs = txSkeleton.get('outputs').toArray();
        after = createCapacitySnapshot(inputs, outputs);
    }
    // If no needed capacity, but has remained capacity needed to be return
    if (calculated.neededCapacity.lte(0) && calculated.remainCapacity.gt(0)) {
        const parsedChangeInfo = (0, common_scripts_1.parseFromInfo)(changeInfo, {
            config: props.config,
        });
        const changeCell = {
            cellOutput: {
                lock: parsedChangeInfo.fromScript,
                capacity: calculated.remainCapacity.toHexString(),
            },
            data: '0x',
        };
        txSkeleton = txSkeleton.update('outputs', (outputs) => {
            return outputs.push(changeCell);
        });
    }
    return {
        txSkeleton,
        before,
        after,
    };
}
exports.injectNeededCapacity = injectNeededCapacity;
//# sourceMappingURL=capacity.js.map