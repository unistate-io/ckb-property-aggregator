import { BIish } from '@ckb-lumos/bi';
import { BI, helpers } from '@ckb-lumos/lumos';
import { Config } from '@ckb-lumos/config-manager';
import { Address, Script, Cell } from '@ckb-lumos/base';
import { FromInfo } from '@ckb-lumos/common-scripts';
/**
 * Calculate target cell's minimal occupied capacity by lock script.
 */
export declare function minimalCellCapacityByLock(lock: Script): BI;
/**
 * Fix cell's minimal occupied capacity by 'helpers.minimalCellCapacityCompatible' API.

 * Note: this function will modify the original cell object.
 */
export declare function correctCellMinimalCapacity(cell: Cell): Cell;
/**
 * Make sure the target cell has declared enough amount of capacity.
 */
export declare function assetCellMinimalCapacity(cell: Cell): void;
/**
 * Calculate the target cell's capacity margin.
 * Could be negative if the cell's declared capacity is not enough.
 */
export declare function getCellCapacityMargin(cell: Cell): BI;
/**
 * Set absolute capacity margin for a cell.
 * The term 'absolute' means the cell's capacity will be: 'minimal capacity' + 'capacity margin'.
 */
export declare function setAbsoluteCapacityMargin(cell: Cell, capacityMargin: BIish | ((cell: Cell, margin: BI) => BIish)): Cell;
/**
 * Count the total containing capacity of a cells list.
 */
export declare function getCellsTotalCapacity(cells: Cell[]): BI;
/**
 * Calculate the summary of capacity/length difference between inputs and outputs.
 */
export declare function createCapacitySnapshot(inputs: Cell[], outputs: Cell[]): {
    inputsLength: number;
    outputsLength: number;
    inputsCapacity: BI;
    outputsCapacity: BI;
    inputsRemainCapacity: BI;
    outputsRemainCapacity: BI;
};
/**
 * Calculates the capacity different in Transaction.inputs and Transaction.outputs,
 * then fix the change cell's containing capacity if inputs' total capacity has any left.
 *
 * Note: normally the change cell is the last cell in Transaction.outputs,
 * but if things are different you can also provide the change cell's output index.
 */
export declare function correctChangeCellCapacity(props: {
    txSkeleton: helpers.TransactionSkeletonType;
    changeOutputIndex?: number;
}): helpers.TransactionSkeletonType;
/**
 * Calculate the capacity difference between Transaction.inputs and Transaction.outputs,
 * and see how much capacity is needed for the transaction to be constructed.
 */
export declare function calculateNeededCapacity(props: {
    txSkeleton: helpers.TransactionSkeletonType;
    fromInfo: FromInfo;
    config?: Config;
    fee?: BIish;
}): {
    snapshot: {
        inputsLength: number;
        outputsLength: number;
        inputsCapacity: BI;
        outputsCapacity: BI;
        inputsRemainCapacity: BI;
        outputsRemainCapacity: BI;
    };
    estimatedFee: BI;
    neededCapacity: BI;
    remainCapacity: BI;
};
/**
 * Calculate the minimal required capacity for the transaction to be constructed,
 * and then collect ckb cells to inputs, it also fills cellDeps and witnesses.
 * After collecting, it will generate an output to return unused ckb.
 *
 * Note: The function also collects for estimated transaction fee.
 */
export declare function injectNeededCapacity(props: {
    txSkeleton: helpers.TransactionSkeletonType;
    fromInfos: FromInfo[];
    fee?: BIish;
    config?: Config;
    changeAddress?: Address;
    enableDeductCapacity?: boolean;
}): Promise<{
    txSkeleton: helpers.TransactionSkeletonType;
    before: ReturnType<typeof createCapacitySnapshot>;
    after?: ReturnType<typeof createCapacitySnapshot>;
}>;
