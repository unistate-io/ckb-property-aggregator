"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.injectNewClusterOutput = void 0;
const codec_1 = require("@ckb-lumos/codec");
const helper_1 = require("@ckb-lumos/common-scripts/lib/helper");
const codec_2 = require("../../../codec");
const config_1 = require("../../../config");
const helpers_1 = require("../../../helpers");
const injectNewClusterIds_1 = require("./injectNewClusterIds");
function injectNewClusterOutput(props) {
    // Env
    const config = props.config ?? (0, config_1.getSporeConfig)();
    // Get TransactionSkeleton
    let txSkeleton = props.txSkeleton;
    // Create cluster cell (with the latest version of ClusterType script)
    const clusterScript = (0, config_1.getSporeScript)(config, 'Cluster');
    let clusterCell = (0, helpers_1.correctCellMinimalCapacity)({
        cellOutput: {
            capacity: '0x0',
            lock: props.toLock,
            type: {
                ...clusterScript.script,
                args: '0x' + '0'.repeat(64), // Fill 32-byte TypeId placeholder
            },
        },
        data: codec_1.bytes.hexify((0, codec_2.packRawClusterData)(props.data)),
    });
    // Add to Transaction.outputs
    const outputIndex = txSkeleton.get('outputs').size;
    txSkeleton = txSkeleton.update('outputs', (outputs) => {
        if (props.capacityMargin !== void 0) {
            clusterCell = (0, helpers_1.setAbsoluteCapacityMargin)(clusterCell, props.capacityMargin);
        }
        if (props.updateOutput instanceof Function) {
            clusterCell = props.updateOutput(clusterCell);
        }
        return outputs.push(clusterCell);
    });
    // Fix the output's index to prevent it from future reduction
    txSkeleton = txSkeleton.update('fixedEntries', (fixedEntries) => {
        return fixedEntries.push({
            field: 'outputs',
            index: outputIndex,
        });
    });
    // Generate ID for the new cluster if possible
    const firstInput = txSkeleton.get('inputs').first();
    if (firstInput) {
        txSkeleton = (0, injectNewClusterIds_1.injectNewClusterIds)({
            outputIndices: [outputIndex],
            txSkeleton,
            config,
        });
    }
    // Add cluster required dependencies
    txSkeleton = (0, helper_1.addCellDep)(txSkeleton, clusterScript.cellDep);
    return {
        txSkeleton,
        outputIndex,
        hasId: firstInput !== void 0,
    };
}
exports.injectNewClusterOutput = injectNewClusterOutput;
//# sourceMappingURL=injectNewClusterOutput.js.map