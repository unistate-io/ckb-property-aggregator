"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.injectNewSporeOutput = void 0;
const codec_1 = require("@ckb-lumos/codec");
const helper_1 = require("@ckb-lumos/common-scripts/lib/helper");
const codec_2 = require("../../../codec");
const helpers_1 = require("../../../helpers");
const helpers_2 = require("../../../helpers");
const config_1 = require("../../../config");
const injectLiveClusterCell_1 = require("../cluster/injectLiveClusterCell");
const getCluster_1 = require("../cluster/getCluster");
const injectNewSporeIds_1 = require("./injectNewSporeIds");
async function injectNewSporeOutput(props) {
    // Env
    const config = props.config ?? (0, config_1.getSporeConfig)();
    const sporeData = props.data;
    // Get TransactionSkeleton
    let txSkeleton = props.txSkeleton;
    // If the creating spore requires a cluster, collect it to inputs/outputs to prove it's unlockable
    let injectClusterCellResult;
    if (sporeData.clusterId) {
        injectClusterCellResult = await (0, injectLiveClusterCell_1.injectLiveClusterCell)({
            cell: await (0, getCluster_1.getClusterById)(sporeData.clusterId, config),
            capacityMargin: props.cluster?.capacityMargin,
            updateWitness: props.cluster?.updateWitness,
            updateOutput: props.cluster?.updateOutput,
            addOutput: true,
            txSkeleton,
            config,
        });
        txSkeleton = injectClusterCellResult.txSkeleton;
    }
    // Create spore cell (with the latest version of SporeType script)
    const sporeScript = (0, config_1.getSporeScript)(config, 'Spore');
    let sporeCell = (0, helpers_2.correctCellMinimalCapacity)({
        cellOutput: {
            capacity: '0x0',
            lock: props.toLock,
            type: {
                ...sporeScript.script,
                args: '0x' + '0'.repeat(64), // Fill 32-byte TypeId placeholder
            },
        },
        data: codec_1.bytes.hexify((0, codec_2.packRawSporeData)({
            contentType: (0, helpers_1.setContentTypeParameters)(sporeData.contentType, sporeData.contentTypeParameters ?? {}),
            content: sporeData.content,
            clusterId: sporeData.clusterId,
        })),
    });
    // Add to Transaction.outputs
    const outputIndex = txSkeleton.get('outputs').size;
    txSkeleton = txSkeleton.update('outputs', (outputs) => {
        if (props.capacityMargin !== void 0) {
            sporeCell = (0, helpers_2.setAbsoluteCapacityMargin)(sporeCell, props.capacityMargin);
        }
        if (props.updateOutput instanceof Function) {
            sporeCell = props.updateOutput(sporeCell);
        }
        return outputs.push(sporeCell);
    });
    // Fix output indices to prevent them from future reduction
    txSkeleton = txSkeleton.update('fixedEntries', (fixedEntries) => {
        // Fix the spore's output index to prevent it from future reduction
        fixedEntries = fixedEntries.push({
            field: 'outputs',
            index: outputIndex,
        });
        // Fix the dep cluster's output index to prevent it from future reduction
        if (sporeData.clusterId && !!injectClusterCellResult) {
            fixedEntries = fixedEntries.push({
                field: 'outputs',
                index: injectClusterCellResult.outputIndex,
            });
        }
        return fixedEntries;
    });
    // Generate Spore Id if possible
    const firstInput = txSkeleton.get('inputs').first();
    if (firstInput !== void 0) {
        txSkeleton = (0, injectNewSporeIds_1.injectNewSporeIds)({
            outputIndices: [outputIndex],
            txSkeleton,
            config,
        });
    }
    // Add Spore cellDeps
    txSkeleton = (0, helper_1.addCellDep)(txSkeleton, sporeScript.cellDep);
    // Add dep cluster to cellDeps, if exists
    if (injectClusterCellResult) {
        const clusterCell = txSkeleton.get('inputs').get(injectClusterCellResult.inputIndex);
        txSkeleton = (0, helper_1.addCellDep)(txSkeleton, {
            outPoint: clusterCell.outPoint,
            depType: 'code',
        });
    }
    return {
        txSkeleton,
        outputIndex,
        hasId: firstInput !== void 0,
        cluster: injectClusterCellResult
            ? {
                inputIndex: injectClusterCellResult.inputIndex,
                outputIndex: injectClusterCellResult.outputIndex,
            }
            : void 0,
    };
}
exports.injectNewSporeOutput = injectNewSporeOutput;
//# sourceMappingURL=injectNewSporeOutput.js.map