"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createSpore = void 0;
const lumos_1 = require("@ckb-lumos/lumos");
const config_1 = require("../../../config");
const helpers_1 = require("../../../helpers");
const helpers_2 = require("../../../helpers");
const __1 = require("../..");
async function createSpore(props) {
    // Env
    const config = props.config ?? (0, config_1.getSporeConfig)();
    const indexer = new lumos_1.Indexer(config.ckbIndexerUrl, config.ckbNodeUrl);
    const capacityMargin = lumos_1.BI.from(props.capacityMargin ?? 1_0000_0000);
    const maxTransactionSize = props.maxTransactionSize ?? config.maxTransactionSize ?? false;
    // Get TransactionSkeleton
    let txSkeleton = lumos_1.helpers.TransactionSkeleton({
        cellProvider: indexer,
    });
    // Create and inject a new spore cell, also inject cluster if exists
    const injectNewSporeResult = await (0, __1.injectNewSporeOutput)({
        data: props.data,
        toLock: props.toLock,
        capacityMargin: props.capacityMargin,
        updateOutput(cell) {
            if (capacityMargin.gt(0)) {
                cell = (0, helpers_2.setAbsoluteCapacityMargin)(cell, capacityMargin);
            }
            if (props.updateOutput instanceof Function) {
                cell = props.updateOutput(cell);
            }
            return cell;
        },
        cluster: props.cluster,
        txSkeleton,
        config,
    });
    txSkeleton = injectNewSporeResult.txSkeleton;
    // Inject needed capacity and pay fee
    const injectCapacityAndPayFeeResult = await (0, helpers_2.injectCapacityAndPayFee)({
        txSkeleton,
        changeAddress: props.changeAddress,
        fromInfos: props.fromInfos,
        fee: lumos_1.BI.from(0),
        config,
    });
    txSkeleton = injectCapacityAndPayFeeResult.txSkeleton;
    // Generate and inject spore id
    txSkeleton = (0, __1.injectNewSporeIds)({
        outputIndices: [injectNewSporeResult.outputIndex],
        txSkeleton,
        config,
    });
    // Make sure the tx size is in range (if needed)
    if (typeof maxTransactionSize === 'number') {
        (0, helpers_1.assetTransactionSkeletonSize)(txSkeleton, void 0, maxTransactionSize);
    }
    return {
        txSkeleton,
        outputIndex: injectNewSporeResult.outputIndex,
        cluster: injectNewSporeResult.cluster,
    };
}
exports.createSpore = createSpore;
//# sourceMappingURL=createSpore.js.map