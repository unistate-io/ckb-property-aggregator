{"version":3,"file":"api.js","names":[],"sources":["../src/api.ts"],"sourcesContent":["// TODO: this file is a copy of jsonrpc-types/src/blockchain.rs\n//  it provides some basic types for RPC, also for Lumos,\n//  but it is not a good idea to use these types directly,\n//  RPC types are not stable, Lumos is better to define its own types\n//  instead of using the RPC types in the future, the api.ts is a legacy solution.\n//  To map the RPC types, it is better to 1:1 map the `jsonrpc-types` from the ckb repo,\n//  at https://github.com/nervosnetwork/ckb/tree/develop/util/jsonrpc-types/src\n//  with the same directory structure.\n\nimport {\n  Hash,\n  Hexadecimal,\n  HexNumber,\n  HexString,\n  PackedSince,\n} from \"./primitive\";\n\nexport interface Header {\n  timestamp: HexNumber;\n  number: HexNumber;\n  epoch: HexNumber;\n  compactTarget: HexNumber;\n  dao: Hash;\n  hash: Hash;\n  nonce: HexNumber;\n  parentHash: Hash;\n  proposalsHash: Hash;\n  transactionsRoot: Hash;\n  extraHash: Hash;\n  version: HexNumber;\n}\n\nexport type HashType = \"type\" | \"data\" | \"data1\" | \"data2\";\nexport interface Script {\n  codeHash: Hash;\n  hashType: HashType;\n  args: HexString;\n}\n\nexport interface OutPoint {\n  txHash: Hash;\n  index: HexNumber;\n}\n\nexport type DepType = \"depGroup\" | \"code\";\nexport interface CellDep {\n  outPoint: OutPoint;\n  depType: DepType;\n}\n\nexport interface Input {\n  previousOutput: OutPoint;\n  since: PackedSince;\n}\n\nexport interface Output {\n  capacity: HexString;\n  lock: Script;\n  type?: Script;\n}\n\nexport interface WitnessArgs {\n  lock?: HexString;\n  inputType?: HexString;\n  outputType?: HexString;\n}\nexport interface RawTransaction {\n  cellDeps: CellDep[];\n  hash?: Hash;\n  headerDeps: Hash[];\n  inputs: Input[];\n  outputs: Output[];\n  outputsData: HexString[];\n  version: HexString;\n}\nexport interface Transaction {\n  cellDeps: CellDep[];\n  hash?: Hash;\n  headerDeps: Hash[];\n  inputs: Input[];\n  outputs: Output[];\n  outputsData: HexString[];\n  version: HexNumber;\n  witnesses: HexString[];\n}\n\ntype Status = \"pending\" | \"proposed\" | \"committed\" | \"unknown\" | \"rejected\";\n\nexport interface TxStatus {\n  status: Status;\n  blockHash?: Hash;\n  reason?: string;\n}\n\nexport interface TransactionWithStatus<Tx = Transaction> {\n  transaction: Tx;\n  txStatus: TxStatus;\n  timeAddedToPool: Uint64 | null;\n  cycles: Uint64 | null;\n}\n\nexport interface Cell {\n  cellOutput: {\n    capacity: HexNumber;\n    lock: Script;\n    type?: Script;\n  };\n  data: HexString;\n  outPoint?: OutPoint;\n  blockHash?: Hash;\n  blockNumber?: HexNumber;\n  txIndex?: HexNumber;\n}\n\nexport interface UncleBlock {\n  header: Header;\n  proposals: HexString[];\n}\n\nexport interface Block {\n  header: Header;\n  transactions: Transaction[];\n  uncles: UncleBlock[];\n  proposals: HexString[];\n}\n\nexport interface LiveCell {\n  data: {\n    content: HexString;\n    hash: Hash;\n  };\n  output: Output;\n}\nexport interface CellWithStatus {\n  cell: LiveCell | null;\n  status: \"live\" | \"unknown\";\n}\n\nexport interface Epoch {\n  compactTarget: HexNumber;\n  length: HexNumber;\n  startNumber: HexNumber;\n  number: HexNumber;\n}\n\nexport interface BlockEconomicState {\n  issuance: {\n    primary: HexNumber;\n    secondary: HexNumber;\n  };\n  minerReward: {\n    primary: HexNumber;\n    secondary: HexNumber;\n    committed: HexNumber;\n    proposal: HexNumber;\n  };\n  txsFee: HexNumber;\n  finalizedAt: Hash;\n}\n\nexport interface MerkleProof {\n  indices: HexNumber[];\n  lemmas: Hash[];\n}\n\nexport interface TransactionProof {\n  blockHash: Hash;\n  witnessesRoot: Hash;\n  proof: MerkleProof;\n}\n\nexport interface Rational {\n  denom: HexNumber;\n  numer: HexNumber;\n}\n\nexport interface ProposalWindow {\n  closest: HexNumber;\n  farthest: HexNumber;\n}\n\nexport interface Consensus {\n  id: string;\n  genesisHash: Hash;\n  daoTypeHash?: Hash;\n  secp256k1Blake160SighashAllTypeHash?: Hash;\n  secp256k1Blake160MultisigAllTypeHash?: Hash;\n  initialPrimaryEpochReward: HexNumber;\n  secondaryEpochReward: HexNumber;\n  maxUnclesNum: HexNumber;\n  orphanRateTarget: Rational;\n  epochDurationTarget: HexNumber;\n  txProposalWindow: ProposalWindow;\n  proposerRewardRatio: Rational;\n  cellbaseMaturity: HexNumber;\n  medianTimeBlockCount: HexNumber;\n  maxBlockCycles: HexNumber;\n  maxBlockBytes: HexNumber;\n  blockVersion: HexNumber;\n  txVersion: HexNumber;\n  typeIdCodeHash: Hash;\n  maxBlockProposalsLimit: HexNumber;\n  primaryEpochRewardHalvingInterval: HexNumber;\n  permanentDifficultyInDummy: boolean;\n  // added this field by: https://github.com/nervosnetwork/ckb/pull/2879\n  hardforkFeatures: HardForks;\n  softforks: MapLike<DeploymentPos, SoftFork>;\n}\n\nexport type HardForks = HardforkFeature[];\n\nexport interface HardforkFeature {\n  rfc: string;\n  epochNumber: EpochNumber | null;\n}\n\nexport type SoftForkStatus = \"buried\" | \"rfc0043\";\n\nexport type SoftFork = Buried | Rfc0043;\n\nexport type Buried = {\n  status: SoftForkStatus;\n  active: boolean;\n  epoch: EpochNumber;\n};\n\nexport type Rfc0043 = {\n  status: SoftForkStatus;\n  rfc0043: Deployment;\n};\n\nexport type Ratio = {\n  numer: Uint64;\n  denom: Uint64;\n};\n\nexport type Deployment = {\n  bit: number;\n  start: EpochNumber;\n  timeout: EpochNumber;\n  minActivationEpoch: EpochNumber;\n  period: EpochNumber;\n  threshold: Ratio;\n};\n\nexport interface DryRunResult {\n  cycles: HexNumber;\n}\n\nexport interface NodeAddress {\n  address: string;\n  score: HexNumber;\n}\n\nexport interface LocalNodeProtocol {\n  id: HexNumber;\n  name: string;\n  supportVersions: string[];\n}\n\nexport interface LocalNode {\n  version: string;\n  nodeId: string;\n  active: boolean;\n  addresses: NodeAddress[];\n  protocols: LocalNodeProtocol[];\n  connections: HexNumber;\n}\n\nexport interface PeerSyncState {\n  bestKnownHeaderHash?: HexString;\n  bestKnownHeaderNumber?: HexNumber;\n  lastCommonHeaderHash?: HexString;\n  lastCommonHeaderNumber?: HexNumber;\n  unknownHeaderListSize?: HexNumber;\n  canFetchCount?: HexNumber;\n  inflightCount?: HexNumber;\n}\n\nexport interface RemoteNodeProtocol {\n  id: HexNumber;\n  version: string;\n}\n\nexport interface RemoteNode {\n  version: string;\n  nodeId: string;\n  addresses: NodeAddress[];\n  isOutbound: boolean;\n  connectedDuration: HexNumber;\n  lastPingDuration?: HexNumber;\n  syncState?: PeerSyncState;\n  protocols: RemoteNodeProtocol[];\n}\n\nexport interface BannedAddr {\n  address: string;\n  banUntil: HexNumber;\n  banReason: string;\n  createdAt: HexNumber;\n}\n\nexport interface SyncState {\n  ibd: boolean;\n  bestKnownBlockNumber: HexNumber;\n  bestKnownBlockTimestamp: HexNumber;\n  orphanBlocksCount: HexNumber;\n  inflightBlocksCount: HexNumber;\n  fastTime: HexNumber;\n  normalTime: HexNumber;\n  lowTime: HexNumber;\n}\n\nexport interface TxPoolInfo {\n  tipHash: Hash;\n  tipNumber: HexNumber;\n  pending: HexNumber;\n  proposed: HexNumber;\n  orphan: HexNumber;\n  totalTxSize: HexNumber;\n  totalTxCycles: HexNumber;\n  minFeeRate: HexNumber;\n  lastTxsUpdatedAt: HexNumber;\n}\n\nexport interface TxPoolIds {\n  pending: Hash[];\n  proposed: Hash[];\n}\n\nexport interface TxVerbosity {\n  cycles: HexNumber;\n  size: HexNumber;\n  fee: HexNumber;\n  ancestorsSize: HexNumber;\n  ancestorsCycles: HexNumber;\n  ancestorsCount: HexNumber;\n}\n\nexport interface TxPoolVerbosity {\n  pending: {\n    [key: string]: TxVerbosity;\n  };\n  proposed: {\n    [key: string]: TxVerbosity;\n  };\n}\n\nexport type RawTxPool = TxPoolIds | TxPoolVerbosity;\n\n/** https://github.com/nervosnetwork/ckb/blob/develop/util/jsonrpc-types/src/alert.rs **/\n\nexport interface AlertMessage {\n  id: HexNumber;\n  priority: HexNumber;\n  noticeUntil: HexNumber;\n  message: string;\n}\n\nexport interface Alert {\n  id: HexNumber;\n  cancel: HexNumber;\n  minVersion?: string;\n  maxVersion?: string;\n  priority: HexNumber;\n  noticeUntil: HexNumber;\n  message: string;\n  signatures: HexString[];\n}\n\n/** https://github.com/nervosnetwork/ckb/blob/develop/util/jsonrpc-types/src/info.rs **/\n\nexport type DeploymentPos = \"testdummy\" | \"lightClient\";\nexport type DeploymentState =\n  | \"defined\"\n  | \"started\"\n  | \"lockedIn\"\n  | \"active\"\n  | \"failed\";\nexport type DeploymentsInfo = {\n  hash: Hash;\n  epoch: EpochNumber;\n  deployments: MapLike<DeploymentPos, DeploymentInfo>;\n};\nexport type DeploymentInfo = {\n  //  determines which bit in the version field of the block is to be used to signal the softfork lock-in and activation. It is chosen from the set {0,1,2,â€¦,28}.\n  bit: number;\n  start: EpochNumber;\n  timeout: EpochNumber;\n  minActivationEpoch: EpochNumber;\n  period: EpochNumber;\n  threshold: Ratio;\n  since: EpochNumber;\n  state: DeploymentState;\n};\n\nexport interface ChainInfo {\n  chain: string;\n  medianTime: HexNumber;\n  epoch: EpochNumberWithFraction;\n  difficulty: HexNumber;\n  isInitialBlockDownload: boolean;\n  alerts: AlertMessage[];\n}\n\ntype Uint64 = Hexadecimal;\ntype EpochNumber = Hexadecimal;\ntype EpochNumberWithFraction = Uint64;\n\n// this is a type to mapping the `HashMap`, `BTreeMap` in `jsonrpc-types`\n// there are some returns of CKB RPC are in this format, like `Softfork`\ntype MapLike<K extends string, V> = {\n  [key in K]?: V;\n};\n"],"mappings":""}