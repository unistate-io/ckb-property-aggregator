{"version":3,"file":"indexer.js","names":["_toolkit","require","_utils","_helpers","Indexer","exports","TransactionCollector","constructor","indexer","lock","type","argsLen","fromBlock","toBlock","order","skip","skipMissing","includeStatus","Error","isScriptWrapper","validators","ValidateScript","script","ioType","assertHexadecimal","rpc","getTransactionHashes","count","hashes","length","collect","hash","tx","get_transaction","transaction","_default","default"],"sources":["../src/indexer.ts"],"sourcesContent":["import { validators } from \"@ckb-lumos/toolkit\";\nimport { assertHexadecimal } from \"./utils\";\n\nimport { Cell, Script, Transaction, TransactionWithStatus } from \"./api\";\nimport { Hexadecimal, HexString } from \"./primitive\";\nimport { Logger } from \"./logger\";\nimport { isScriptWrapper } from \"./helpers\";\n\nexport type SearchMode = \"exact\" | \"prefix\";\n\nexport type DataWithSearchMode = {\n  searchMode: SearchMode;\n  data: HexString;\n};\n\n/**\n * argsLen: if argsLen = 20, it means collected cells cell.cellOutput.lock.args should be 20-byte length, and prefix match to lock.args.\n * And if argsLen = -1 (default), means cell.cellOutput.lock.args should equals to lock.args.\n */\nexport interface QueryOptions {\n  lock?: Script | ScriptWrapper;\n  type?: Script | ScriptWrapper | \"empty\";\n  // data = any means any data content is ok\n  data?: string | \"any\" | DataWithSearchMode;\n\n  /** `lock` script args length */\n  argsLen?: number | \"any\";\n  /** `fromBlock` itself is included in range query. */\n  fromBlock?: Hexadecimal;\n  /** `toBlock` itself is included in range query. */\n  toBlock?: Hexadecimal;\n  skip?: number;\n  order?: \"asc\" | \"desc\";\n}\n\nexport interface ScriptWrapper {\n  script: Script;\n  searchMode?: SearchMode;\n  ioType?: \"input\" | \"output\" | \"both\";\n  argsLen?: number | \"any\";\n}\n\nexport interface CellCollectorResults {\n  [Symbol.asyncIterator](): AsyncIterator<Cell>;\n}\n\nexport interface CellCollector {\n  collect(): CellCollectorResults;\n}\n\nexport interface CellProvider {\n  uri?: string;\n  collector(queryOptions: QueryOptions): CellCollector;\n}\n\nexport interface Tip {\n  blockNumber: string;\n  blockHash: string;\n}\n\nexport interface IndexerOptions {\n  pollIntervalSeconds?: number;\n  livenessCheckIntervalSeconds?: number;\n  logger?: Logger;\n  keepNum?: number;\n  pruneInterval?: number;\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  rpcOptions?: object;\n}\n\n/**\n * @deprecated please use CellProvider\n */\nexport abstract class Indexer {\n  abstract uri: string;\n\n  abstract running(): boolean;\n  abstract startForever(): void;\n  abstract start(): void;\n  abstract stop(): void;\n  abstract tip(): Promise<Tip>;\n\n  abstract collector(queries: QueryOptions): CellCollector;\n  abstract subscribe(queries: QueryOptions): NodeJS.EventEmitter;\n  abstract subscribeMedianTime(): NodeJS.EventEmitter;\n  abstract waitForSync(blockDifference?: number): Promise<void>;\n}\n\n// CellCollector\nexport declare interface BaseCellCollector extends CellCollector {\n  count(): Promise<number>;\n\n  collect(): CellCollectorResults;\n}\n\n// TransactionCollector\nexport interface TransactionCollectorOptions {\n  skipMissing?: boolean;\n  includeStatus?: boolean;\n}\n\nexport interface TransactionCollectorResults {\n  [Symbol.asyncIterator](): AsyncIterator<Transaction | TransactionWithStatus>;\n}\n\n// Notice this TransactionCollector implementation only uses indexer\n// here. Since the indexer we use doesn't store full transaction data,\n// we will have to run CKB RPC queries on each tx hash to fetch transaction\n// data. In some cases this might slow your app down. An ideal solution would\n// be combining this with some cacher to accelerate this process.\nclass TransactionCollector {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  rpc: any;\n  lock: ScriptWrapper | undefined;\n  type: \"empty\" | ScriptWrapper | Script | undefined;\n  indexer: Indexer;\n  skipMissing: boolean;\n  includeStatus: boolean;\n  fromBlock: Hexadecimal | undefined;\n  toBlock: Hexadecimal | undefined;\n  order: \"asc\" | \"desc\";\n  skip: number | undefined;\n\n  constructor(\n    indexer: Indexer,\n    {\n      lock,\n      type,\n      argsLen = -1,\n      fromBlock,\n      toBlock,\n      order = \"asc\",\n      skip,\n    }: QueryOptions = {},\n    {\n      skipMissing = false,\n      includeStatus = true,\n    }: TransactionCollectorOptions = {}\n  ) {\n    if (!lock && (!type || type === \"empty\")) {\n      throw new Error(\"Either lock or type script must be provided!\");\n    }\n    // Wrap the plain `Script` into `ScriptWrapper`.\n    if (lock && !isScriptWrapper(lock)) {\n      validators.ValidateScript(lock);\n      this.lock = { script: lock, ioType: \"both\", argsLen: argsLen };\n    } else if (lock && lock.script) {\n      validators.ValidateScript(lock.script);\n      this.lock = lock;\n      // check ioType, argsLen\n      if (!lock.argsLen) {\n        this.lock.argsLen = argsLen;\n      }\n      if (!lock.ioType) {\n        this.lock.ioType = \"both\";\n      }\n    }\n    if (type === \"empty\") {\n      this.type = type;\n    } else if (type && !isScriptWrapper(type)) {\n      validators.ValidateScript(type);\n      this.type = { script: type, ioType: \"both\", argsLen: argsLen };\n    } else if (type && type.script) {\n      validators.ValidateScript(type.script);\n      this.type = type;\n      // check ioType, argsLen\n      if (!type.argsLen) {\n        this.type.argsLen = argsLen;\n      }\n      if (!type.ioType) {\n        this.type.ioType = \"both\";\n      }\n    }\n    if (fromBlock) {\n      assertHexadecimal(\"fromBlock\", fromBlock);\n    }\n    if (toBlock) {\n      assertHexadecimal(\"toBlock\", toBlock);\n    }\n    if (order !== \"asc\" && order !== \"desc\") {\n      throw new Error(\"Order must be either asc or desc!\");\n    }\n    this.indexer = indexer;\n    this.skipMissing = skipMissing;\n    this.includeStatus = includeStatus;\n    this.fromBlock = fromBlock;\n    this.toBlock = toBlock;\n    this.order = order;\n    this.skip = skip;\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    this.rpc = (indexer as any).rpc;\n  }\n\n  async getTransactionHashes(): Promise<HexString[]> {\n    throw new Error(\"Not implement!\");\n  }\n\n  async count(): Promise<number> {\n    const hashes = await this.getTransactionHashes();\n    return hashes.length;\n  }\n\n  async *collect(): TransactionCollectorResults {\n    const hashes = await this.getTransactionHashes();\n    for (const hash of hashes) {\n      const tx = await this.rpc.get_transaction(hash);\n      if (!this.skipMissing && !tx) {\n        throw new Error(`Transaction ${hash} is missing!`);\n      }\n      if (this.includeStatus) {\n        yield tx;\n      } else {\n        yield tx.transaction;\n      }\n    }\n  }\n}\n\nconst indexer = {\n  TransactionCollector,\n};\n\nexport default indexer;\nexport { TransactionCollector };\n"],"mappings":"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"}