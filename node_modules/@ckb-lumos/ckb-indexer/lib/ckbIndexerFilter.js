"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.convertQueryOptionToLumosSearchKey = convertQueryOptionToLumosSearchKey;
exports.filterByLumosQueryOptions = filterByLumosQueryOptions;
exports.filterByLumosSearchKey = filterByLumosSearchKey;
exports.instanceOfDataWithSearchMode = instanceOfDataWithSearchMode;
exports.instanceOfScriptWrapper = instanceOfScriptWrapper;
exports.unwrapScriptWrapper = exports.unwrapDataWrapper = void 0;
var _base = require("@ckb-lumos/base");
var _codec = require("@ckb-lumos/codec");
var _bi = require("@ckb-lumos/bi");
/**
 * @description the following fields are not supported:
 * 1. `fromBlock` pending cells don't have block number
 * 2. `toBlock` pending cells don't have block number
 * 3. `skip` not search key, shoule be implmented in cell collector
 * 4. `order` not search key, shoule be implmented in cell collector
 */

/**
 * @description `blockRange` is not supported, because pending cells don't have block number
 */

function convertQueryOptionToLumosSearchKey(queryOptions) {
  let searchKeyLock;
  let searchKeyType;
  let searchKey;
  const queryLock = queryOptions.lock;
  const queryType = queryOptions.type;
  if (queryLock) {
    if (instanceOfScriptWrapper(queryLock)) {
      searchKeyLock = queryLock.script;
    } else {
      searchKeyLock = queryLock;
    }
  }
  if (queryType && queryType !== "empty") {
    if (instanceOfScriptWrapper(queryType)) {
      searchKeyType = queryType.script;
    } else {
      searchKeyType = queryType;
    }
  }
  if (searchKeyLock) {
    searchKey = {
      script: searchKeyLock,
      scriptType: "lock",
      scriptSearchMode: instanceOfScriptWrapper(queryLock) ? queryLock.searchMode || "prefix" : "prefix",
      filter: {}
    };
    searchKeyType && (searchKey.filter.script = searchKeyType);
  } else if (searchKeyType) {
    searchKey = {
      script: searchKeyType,
      scriptType: "type",
      scriptSearchMode: instanceOfScriptWrapper(queryType) ? queryType.searchMode || "prefix" : "prefix",
      filter: {}
    };
  } else {
    throw new Error("query.lock and query.type can't be both empty");
  }
  const {
    outputDataLenRange,
    outputCapacityRange,
    scriptLenRange
  } = queryOptions;
  searchKey.filter.outputDataLenRange = outputDataLenRange;
  searchKey.filter.outputCapacityRange = outputCapacityRange;
  searchKey.filter.scriptLenRange = scriptLenRange;
  if (queryType === "empty") {
    searchKey.filter.scriptLenRange = ["0x0", "0x1"];
  }
  return searchKey;
}
function filterByLumosQueryOptions(cells, options) {
  const searchKey = convertQueryOptionToLumosSearchKey(options);
  let filteredCells = cells.filter(cell => filterByLumosSearchKey(cell, searchKey));
  if (options.argsLen && options.argsLen !== "any" && options.argsLen !== -1) {
    filteredCells = filteredCells.filter(cell => _codec.bytes.bytify(cell.cellOutput.lock.args).length === options.argsLen);
  }
  if (!!options.data && options.data !== "any") {
    if (instanceOfDataWithSearchMode(options.data) && options.data.searchMode === "exact") {
      const dataSearch = options.data;
      filteredCells = filteredCells.filter(cell => _codec.bytes.equal(_codec.bytes.bytify(cell.data), _codec.bytes.bytify(dataSearch.data)));
    } else if (instanceOfDataWithSearchMode(options.data) && options.data.searchMode === "prefix") {
      const dataSearch = options.data;
      filteredCells = filteredCells.filter(cell => {
        const expectPrefix = _codec.bytes.bytify(dataSearch.data);
        const actualPrefix = _codec.bytes.bytify(cell.data).slice(0, expectPrefix.length);
        return _codec.bytes.equal(expectPrefix, actualPrefix);
      });
    } else {
      filteredCells = filteredCells.filter(cell => {
        const expectPrefix = _codec.bytes.bytify(options.data);
        const actualPrefix = _codec.bytes.bytify(cell.data).slice(0, expectPrefix.length);
        return _codec.bytes.equal(expectPrefix, actualPrefix);
      });
    }
  }
  return filteredCells;
}

/**
 * @internal
 */
function filterByLumosSearchKey(cell, searchKey) {
  const isExactMode = searchKey.scriptSearchMode === "exact";
  const {
    cellOutput
  } = cell;
  const {
    scriptType,
    script,
    filter
  } = searchKey;

  // Search mode
  if (isExactMode) {
    if (scriptType === "lock") {
      if (!_codec.bytes.equal(_base.blockchain.Script.pack(cellOutput.lock), _base.blockchain.Script.pack(script))) {
        return false;
      }
    } else {
      if (!cellOutput.type || !_codec.bytes.equal(_base.blockchain.Script.pack(cellOutput.type), _base.blockchain.Script.pack(script))) {
        return false;
      }
    }
    // Prefix mode
  } else {
    if (scriptType === "lock") {
      if (!checkScriptWithPrefixMode(cellOutput.lock, script)) {
        return false;
      }
    } else {
      if (!checkScriptWithPrefixMode(cellOutput.type, script)) {
        return false;
      }
    }
  }

  // the "exact" mode works only on "SearchKey.script",
  // not on "SearchKey.filter.script"
  // the "SearchKey.filter.script" is always in prefix mode
  if (!filter) return true;
  // filter type script if scriptType is "lock"
  if (scriptType === "lock") {
    if (filter.script && !checkScriptWithPrefixMode(cellOutput.type, filter.script)) {
      return false;
    }
    if (filter.scriptLenRange && !checkScriptLenRange(cellOutput.type, filter.scriptLenRange)) {
      return false;
    }
    // filter lock script if scriptType is "type"
  } else {
    if (filter.script && !checkScriptWithPrefixMode(cellOutput.lock, filter.script)) {
      return false;
    }
    if (filter.scriptLenRange && !checkScriptLenRange(cellOutput.lock, filter.scriptLenRange)) {
      return false;
    }
  }
  const {
    outputCapacityRange,
    outputDataLenRange
  } = filter;
  if (outputCapacityRange) {
    const capacity = _bi.BI.from(cellOutput.capacity);
    const fromCapacity = _bi.BI.from(outputCapacityRange[0]);
    const toCapacity = _bi.BI.from(outputCapacityRange[1]);
    if (capacity.lt(fromCapacity) || capacity.gte(toCapacity)) {
      return false;
    }
  }
  if (outputDataLenRange) {
    const dataLen = _bi.BI.from(_codec.bytes.bytify(cell.data).length);
    const fromDataLen = _bi.BI.from(outputDataLenRange[0]);
    const toDataLen = _bi.BI.from(outputDataLenRange[1]);
    if (dataLen.lt(fromDataLen) || dataLen.gte(toDataLen)) {
      return false;
    }
  }
  return true;
}
function checkScriptWithPrefixMode(script, filterScript) {
  if (!script) {
    return false;
  }

  // codeHash should always be 32 bytes, so it only supports exact match mode
  if (!_codec.bytes.equal(filterScript.codeHash, script.codeHash)) {
    return false;
  }
  const expectArgsPrefix = _codec.bytes.bytify(filterScript.args);
  const actualArgsPrefix = _codec.bytes.bytify(script.args).slice(0, expectArgsPrefix.length);
  if (!_codec.bytes.equal(expectArgsPrefix, actualArgsPrefix)) {
    return false;
  }
  if (script.hashType !== filterScript.hashType) {
    return false;
  }
  return true;
}
function checkScriptLenRange(script, scriptLenRange) {
  const scriptLen = script ? _bi.BI.from(_codec.bytes.concat(script.codeHash, script.args).length + 1 /* hashType length is 1 */) : _bi.BI.from(0);
  const fromScriptLen = _bi.BI.from(scriptLenRange[0]);
  const toScriptLen = _bi.BI.from(scriptLenRange[1]);
  if (scriptLen.lt(fromScriptLen) || scriptLen.gte(toScriptLen)) {
    return false;
  }
  return true;
}
function instanceOfScriptWrapper(object) {
  return typeof object === "object" && object != null && "script" in object;
}
function instanceOfDataWithSearchMode(object) {
  return typeof object === "object" && object != null && "data" in object;
}
const unwrapScriptWrapper = inputScript => {
  if (instanceOfScriptWrapper(inputScript)) {
    return inputScript.script;
  }
  return inputScript;
};
exports.unwrapScriptWrapper = unwrapScriptWrapper;
const unwrapDataWrapper = input => {
  if (instanceOfDataWithSearchMode(input)) {
    return input.data;
  }
  return input;
};
exports.unwrapDataWrapper = unwrapDataWrapper;
//# sourceMappingURL=ckbIndexerFilter.js.map