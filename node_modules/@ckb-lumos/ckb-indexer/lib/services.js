"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getHexStringBytes = exports.generateSearchKey = void 0;
exports.requestBatch = requestBatch;
exports.requestBatchTransactionWithStatus = requestBatchTransactionWithStatus;
var _base = require("@ckb-lumos/base");
var _crossFetch = _interopRequireDefault(require("cross-fetch"));
var _bi = require("@ckb-lumos/bi");
var _paramsFormatter = require("./paramsFormatter");
var _resultFormatter = require("./resultFormatter");
var _ckbIndexerFilter = require("./ckbIndexerFilter");
var _rpc = require("@ckb-lumos/rpc");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const generateSearchKey = queries => {
  let script = undefined;
  const filter = {};
  let script_type = undefined;
  let script_search_mode = "prefix";
  if (queries.lock) {
    const lock = (0, _ckbIndexerFilter.unwrapScriptWrapper)(queries.lock);
    script = (0, _paramsFormatter.toScript)(lock);
    script_type = "lock";
    if (queries.type && typeof queries.type !== "string") {
      const type = (0, _ckbIndexerFilter.unwrapScriptWrapper)(queries.type);
      filter.script = (0, _paramsFormatter.toScript)(type);
    }
  } else if (queries.type && typeof queries.type !== "string") {
    const type = (0, _ckbIndexerFilter.unwrapScriptWrapper)(queries.type);
    script = (0, _paramsFormatter.toScript)(type);
    script_type = "type";
  }
  let block_range = null;
  if (queries.fromBlock && queries.toBlock) {
    //toBlock+1 cause toBlock need to be included
    block_range = [queries.fromBlock, `0x${_bi.BI.from(queries.toBlock).add(1).toString(16)}`];
  }
  if (block_range) {
    filter.block_range = block_range;
  }
  if (queries.outputDataLenRange) {
    filter.output_data_len_range = queries.outputDataLenRange;
  }
  if (queries.outputCapacityRange) {
    filter.output_capacity_range = queries.outputCapacityRange;
  }
  if (queries.scriptLenRange) {
    filter.script_len_range = queries.scriptLenRange;
  }
  if (queries.scriptSearchMode) {
    script_search_mode = queries.scriptSearchMode;
  }
  if (!script) {
    throw new Error("Either lock or type script must be provided!");
  }
  if (!script_type) {
    throw new Error("script_type must be provided");
  }
  return (0, _resultFormatter.toSearchKey)({
    script,
    script_type,
    filter,
    script_search_mode
  });
};
exports.generateSearchKey = generateSearchKey;
const getHexStringBytes = hexString => {
  _base.utils.assertHexString("", hexString);
  return Math.ceil(hexString.substr(2).length / 2);
};
exports.getHexStringBytes = getHexStringBytes;
let id = 0;
// will be tested in e2e
/* c8 ignore next 25 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
async function requestBatch(rpcUrl,
// eslint-disable-next-line
data) {
  if (!data.length) {
    return [];
  }
  const res = await (0, _crossFetch.default)(rpcUrl, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify(data.map(item => ({
      id: id++,
      ...item
    })))
  });
  if (res.status !== 200) {
    throw new Error(`Indexer request failed with HTTP code ${res.status}`);
  }
  const result = await res.json();
  if (result.error !== undefined) {
    throw new Error(`indexer request rpc failed with error: ${JSON.stringify(result.error)}`);
  }
  return result;
}

/* c8 ignore next 23 */
async function requestBatchTransactionWithStatus(rpcUrl, txHashes) {
  if (txHashes.length === 0) {
    return [];
  }
  const requestBody = txHashes.map((txHash, index) => {
    return {
      id: index,
      jsonrpc: "2.0",
      method: "get_transaction",
      params: [txHash]
    };
  });
  const res = await requestBatch(rpcUrl, requestBody);
  return res.map(item => _rpc.ResultFormatter.toTransactionWithStatus(item.result));
}
//# sourceMappingURL=services.js.map