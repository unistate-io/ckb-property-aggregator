{"version":3,"file":"transaction_collector.js","names":["_base","require","_ckbIndexerFilter","services","_interopRequireWildcard","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","obj","__esModule","default","cache","has","get","newObj","hasPropertyDescriptor","Object","defineProperty","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","_defineProperty","value","_toPropertyKey","enumerable","configurable","writable","arg","_toPrimitive","String","input","hint","prim","Symbol","toPrimitive","undefined","res","TypeError","Number","CKBIndexerTransactionCollector","BaseIndexerModule","TransactionCollector","constructor","indexer","queries","CKBRpcUrl","options","indexerTransactionList","getDetailRequestData","objects","map","hashItem","txHash","transactionList","requestBatchTransactionWithStatus","then","response","item","index","filterOptions","skipMissing","transaction","Error","args","argsLen","getHexStringBytes","targetCell","lock","lockArgsLen","instanceOfScriptWrapper","isLockArgsLenMatched","type","_targetCell$type","typeArgsLen","inputResult","ioType","filter","result","filterByIoType","defaultOptions","includeStatus","asBaseTransactionCollector","fetchIndexerTransaction","lastCursor","searchKeyFilter","sizeLimit","bufferSize","order","getTransactionByLockAndTypeIndependent","getTransactions","generateSearchKey","filterByTypeIoTypeAndLockIoType","getResolvedTransactionRequestPayload","unresolvedTransactionList","requestPayload","forEach","unresolvedTransaction","indexerTransaction","unresolvedOutPoint","inputs","ioIndex","previousOutput","push","getResolvedCell","resolvedTransactionList","outputs","resolvedTransaction","find","tx","hash","resolvedCell","filterTransaction","filteredTransactionList","isCellScriptArgsValid","txStatus","cycles","timeAddedToPool","length","getTransactionListFromRpc","queryWithTypeAdditionOptions","queryWithLockAdditionOptions","lockLastCursor","typeLastCursor","split","queriesWithoutType","transactionByLock","queriesWithoutLock","transactionByType","intersection","transactionList1","transactionList2","tx1","tx2","targetTx","hashList","count","getTxWithCursor","counter","txs","buffer","skippedCount","skip","getTransactionHashes","transactionHashes","collect","exports"],"sources":["../src/transaction_collector.ts"],"sourcesContent":["import {\n  TransactionCollectorOptions,\n  indexer as BaseIndexerModule,\n  Output,\n  OutPoint,\n  TransactionWithStatus,\n  TransactionCollector as BaseTransactionCollector,\n  QueryOptions,\n  Transaction,\n} from \"@ckb-lumos/base\";\nimport {\n  SearchKeyFilter,\n  CKBIndexerQueryOptions,\n  IndexerTransaction,\n  IndexerTransactionList,\n  IOType,\n  Order,\n} from \"./type\";\nimport { CkbIndexer } from \"./indexer\";\nimport { instanceOfScriptWrapper } from \"./ckbIndexerFilter\";\nimport * as services from \"./services\";\n\ninterface GetTransactionDetailResult {\n  objects: TransactionWithStatus[];\n  lastCursor: string | undefined;\n}\n\nexport class CKBIndexerTransactionCollector extends BaseIndexerModule.TransactionCollector {\n  filterOptions: TransactionCollectorOptions;\n  constructor(\n    public indexer: CkbIndexer,\n    public queries: CKBIndexerQueryOptions,\n    public CKBRpcUrl: string,\n    public options?: TransactionCollectorOptions\n  ) {\n    super(indexer, queries, options);\n    const defaultOptions: TransactionCollectorOptions = {\n      skipMissing: false,\n      includeStatus: true,\n    };\n    this.filterOptions = { ...defaultOptions, ...this.options };\n  }\n\n  /**\n   * @deprecated\n   * @param CKBRpcUrl\n   */\n  public static asBaseTransactionCollector(\n    CKBRpcUrl: string\n  ): typeof BaseTransactionCollector {\n    return class extends BaseIndexerModule.TransactionCollector {\n      constructor(\n        indexer: CkbIndexer,\n        queries: QueryOptions,\n        options?: TransactionCollectorOptions\n      ) {\n        super(indexer, queries, options);\n        return new CKBIndexerTransactionCollector(\n          indexer,\n          queries,\n          CKBRpcUrl,\n          options\n        );\n      }\n    };\n  }\n  public async fetchIndexerTransaction(\n    queries: CKBIndexerQueryOptions,\n    lastCursor?: string\n  ): Promise<IndexerTransactionList> {\n    const searchKeyFilter: SearchKeyFilter = {\n      sizeLimit: queries.bufferSize,\n      order: queries.order as Order,\n    };\n    if (lastCursor) {\n      searchKeyFilter.lastCursor = lastCursor;\n    }\n    let indexerTransactionList: IndexerTransactionList = {\n      objects: [],\n      lastCursor: \"\",\n    };\n    /*\n     * if both lock and type exist,we need search them in independent and then get intersection\n     * cause ckb-indexer use searchKey script on each cell but native indexer use lock and type on transaction,\n     * and one transaction may have many cells both in input and output, more detail in test 'Test query transaction by both input lock and output type script'\n     */\n\n    //if both lock and type, search search them in independent and then get intersection, GetTransactionsResults.lastCursor change to `${lockLastCursor}-${typeLastCursor}`\n    if (\n      instanceOfScriptWrapper(queries.lock) &&\n      instanceOfScriptWrapper(queries.type)\n    ) {\n      indexerTransactionList =\n        await this.getTransactionByLockAndTypeIndependent(searchKeyFilter);\n      lastCursor = indexerTransactionList.lastCursor;\n    } else {\n      //query by ScriptWrapper.script,block_range,order\n      indexerTransactionList = await this.indexer.getTransactions(\n        services.generateSearchKey(queries),\n        searchKeyFilter\n      );\n      lastCursor = indexerTransactionList.lastCursor;\n    }\n    // filter by ScriptWrapper.io_type\n    indexerTransactionList.objects = this.filterByTypeIoTypeAndLockIoType(\n      indexerTransactionList.objects,\n      queries\n    );\n    return indexerTransactionList;\n  }\n\n  public getResolvedTransactionRequestPayload(\n    unresolvedTransactionList: TransactionWithStatus[],\n    indexerTransactionList: IndexerTransactionList\n  ): string[] {\n    const requestPayload: string[] = [];\n    unresolvedTransactionList.forEach(\n      (unresolvedTransaction: TransactionWithStatus, index: number) => {\n        const indexerTransaction = indexerTransactionList.objects[index];\n        if (indexerTransaction.ioType === \"input\") {\n          const unresolvedOutPoint: OutPoint =\n            unresolvedTransaction.transaction.inputs[\n              Number(indexerTransaction.ioIndex)\n            ].previousOutput;\n          requestPayload.push(unresolvedOutPoint.txHash);\n        }\n      }\n    );\n    return requestPayload;\n  }\n\n  public getResolvedCell(\n    unresolvedTransaction: TransactionWithStatus,\n    resolvedTransactionList: TransactionWithStatus[],\n    indexerTransaction: IndexerTransaction\n  ): Output {\n    if (indexerTransaction.ioType !== \"input\") {\n      return unresolvedTransaction.transaction.outputs[\n        Number(indexerTransaction.ioIndex)\n      ];\n    } else {\n      const unresolvedOutPoint =\n        unresolvedTransaction.transaction.inputs[\n          Number(indexerTransaction.ioIndex)\n        ].previousOutput;\n      const resolvedTransaction = resolvedTransactionList.find((tx) => {\n        return tx.transaction.hash === unresolvedOutPoint.txHash;\n      });\n      if (!resolvedTransaction) {\n        throw new Error(`Impossible: can NOT find resolved transaction!`);\n      }\n      const resolvedCell =\n        resolvedTransaction.transaction.outputs[\n          Number(unresolvedOutPoint.index)\n        ];\n      return resolvedCell;\n    }\n  }\n\n  //filter by ScriptWrapper.argsLen\n  private filterTransaction(\n    unresolvedTransactionList: TransactionWithStatus[],\n    resolvedTransactionList: TransactionWithStatus[],\n    indexerTransactionList: IndexerTransactionList\n  ): TransactionWithStatus[] {\n    const filteredTransactionList = unresolvedTransactionList.filter(\n      (unresolvedTransaction: TransactionWithStatus, index: number) => {\n        const resolvedCell: Output = this.getResolvedCell(\n          unresolvedTransaction,\n          resolvedTransactionList,\n          indexerTransactionList.objects[index]\n        );\n        return this.isCellScriptArgsValid(resolvedCell);\n      }\n    );\n    const objects = filteredTransactionList.map<TransactionWithStatus>(\n      (tx) => ({\n        transaction: tx.transaction,\n        txStatus: tx.txStatus,\n        cycles: tx.cycles,\n        timeAddedToPool: tx.timeAddedToPool,\n      })\n    );\n    return objects;\n  }\n\n  /*\n   *lock?: ScriptWrapper.script query by ckb-indexer,ScriptWrapper.ioType filter after get transaction from indexer, ScriptWrapper.argsLen filter after get transaction from rpc;\n   *type?:  ScriptWrapper.script query by ckb-indexer,ScriptWrapper.ioType filter after get transaction from indexer, ScriptWrapper.argsLen filter after get transaction from rpc;\n   *data?: will not filter\n   *argsLen?: filter after get transaction detail;\n   *fromBlock?: query by ckb-indexer;\n   *toBlock?: query by ckb-indexer;\n   *skip?: filter after get transaction from ckb-indexer;;\n   *order?: query by ckb-indexer;\n   */\n  public async getTransactions(\n    lastCursor?: string\n  ): Promise<GetTransactionDetailResult> {\n    const indexerTransactionList: IndexerTransactionList =\n      await this.fetchIndexerTransaction(this.queries, lastCursor);\n    lastCursor = indexerTransactionList.lastCursor;\n\n    // return if transaction hash list if empty\n    if (indexerTransactionList.objects.length === 0) {\n      return {\n        objects: [],\n        lastCursor: lastCursor,\n      };\n    }\n    const unresolvedTransactionList: TransactionWithStatus[] =\n      await this.getTransactionListFromRpc(indexerTransactionList);\n    const requestPayload = this.getResolvedTransactionRequestPayload(\n      unresolvedTransactionList,\n      indexerTransactionList\n    );\n    const resolvedTransactionList =\n      await services.requestBatchTransactionWithStatus(\n        this.CKBRpcUrl,\n        requestPayload\n      );\n    const objects = this.filterTransaction(\n      unresolvedTransactionList,\n      resolvedTransactionList,\n      indexerTransactionList\n    );\n    return {\n      objects: objects,\n      lastCursor: lastCursor,\n    };\n  }\n\n  private async getTransactionByLockAndTypeIndependent(\n    searchKeyFilter: SearchKeyFilter\n  ): Promise<IndexerTransactionList> {\n    const queryWithTypeAdditionOptions = { ...searchKeyFilter };\n    const queryWithLockAdditionOptions = { ...searchKeyFilter };\n    if (searchKeyFilter.lastCursor) {\n      const [lockLastCursor, typeLastCursor] =\n        searchKeyFilter.lastCursor.split(\"-\");\n      queryWithLockAdditionOptions.lastCursor = lockLastCursor;\n      queryWithTypeAdditionOptions.lastCursor = typeLastCursor;\n    }\n    const queriesWithoutType = { ...this.queries, type: undefined };\n    const transactionByLock = await this.indexer.getTransactions(\n      services.generateSearchKey(queriesWithoutType),\n      queryWithTypeAdditionOptions\n    );\n    const queriesWithoutLock = { ...this.queries, lock: undefined };\n    const transactionByType = await this.indexer.getTransactions(\n      services.generateSearchKey(queriesWithoutLock),\n      queryWithLockAdditionOptions\n    );\n\n    const intersection = (\n      transactionList1: IndexerTransaction[],\n      transactionList2: IndexerTransaction[]\n    ) => {\n      const result: IndexerTransaction[] = [];\n      transactionList1.forEach((tx1) => {\n        const tx2 = transactionList2.find((item) => item.txHash === tx1.txHash);\n        if (tx2) {\n          // put the output io_type to intersection result, cause output have cells\n          const targetTx = tx1.ioType === \"output\" ? tx1 : tx2;\n          // change io_type to both cause targetTx exist both input and output\n          result.push({ ...targetTx, ioType: \"both\" });\n        }\n      });\n      return result;\n    };\n    const hashList = intersection(\n      transactionByType.objects,\n      transactionByLock.objects\n    );\n    const lastCursor =\n      transactionByLock.lastCursor + \"-\" + transactionByType.lastCursor;\n    const objects = hashList;\n    return { objects, lastCursor };\n  }\n\n  private getTransactionListFromRpc = async (\n    indexerTransactionList: IndexerTransactionList\n  ) => {\n    const getDetailRequestData = indexerTransactionList.objects.map(\n      (hashItem: IndexerTransaction) => {\n        return hashItem.txHash;\n      }\n    );\n\n    const transactionList: TransactionWithStatus[] = await services\n      .requestBatchTransactionWithStatus(this.CKBRpcUrl, getDetailRequestData)\n      .then((response) => {\n        return response.map((item, index) => {\n          if (!this.filterOptions.skipMissing && !item.transaction) {\n            throw new Error(\n              `Transaction ${indexerTransactionList.objects[index].txHash} is missing!`\n            );\n          }\n          return item;\n        });\n      });\n    return transactionList;\n  };\n\n  private isLockArgsLenMatched = (\n    args: string | undefined,\n    argsLen?: number | \"any\"\n  ) => {\n    if (!argsLen) return true;\n    if (argsLen === \"any\") return true;\n    if (argsLen === -1) return true;\n    return services.getHexStringBytes(args as string) === argsLen;\n  };\n\n  // only valid after pass flow three validate\n  private isCellScriptArgsValid = (targetCell: Output) => {\n    if (this.queries.lock) {\n      const lockArgsLen = instanceOfScriptWrapper(this.queries.lock)\n        ? this.queries.lock.argsLen\n        : this.queries.argsLen;\n      if (!this.isLockArgsLenMatched(targetCell.lock.args, lockArgsLen)) {\n        return false;\n      }\n    }\n\n    if (this.queries.type && this.queries.type !== \"empty\") {\n      const typeArgsLen = instanceOfScriptWrapper(this.queries.type)\n        ? this.queries.type.argsLen\n        : this.queries.argsLen;\n      if (!this.isLockArgsLenMatched(targetCell.type?.args, typeArgsLen)) {\n        return false;\n      }\n    }\n\n    if (this.queries.type && this.queries.type === \"empty\") {\n      if (targetCell.type) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  private filterByIoType = (\n    inputResult: IndexerTransaction[],\n    ioType: IOType\n  ) => {\n    if (ioType === \"both\") {\n      return inputResult;\n    }\n    if (ioType === \"input\" || ioType === \"output\") {\n      return inputResult.filter(\n        (item: IndexerTransaction) =>\n          item.ioType === ioType || item.ioType === \"both\"\n      );\n    }\n    return inputResult;\n  };\n\n  private filterByTypeIoTypeAndLockIoType = (\n    inputResult: IndexerTransaction[],\n    queries: CKBIndexerQueryOptions\n  ) => {\n    let result = inputResult;\n    if (instanceOfScriptWrapper(queries.lock) && queries.lock.ioType) {\n      result = this.filterByIoType(result, queries.lock.ioType);\n    }\n    if (instanceOfScriptWrapper(queries.type) && queries.type.ioType) {\n      result = this.filterByIoType(result, queries.type.ioType);\n    }\n    return result;\n  };\n\n  async count(): Promise<number> {\n    let lastCursor: undefined | string = undefined;\n    const getTxWithCursor = async (): Promise<TransactionWithStatus[]> => {\n      const result: GetTransactionDetailResult = await this.getTransactions(\n        lastCursor\n      );\n      lastCursor = result.lastCursor;\n      return result.objects;\n    };\n    let counter = 0;\n    let txs: TransactionWithStatus[] = await getTxWithCursor();\n    if (txs.length === 0) {\n      return 0;\n    }\n    let buffer: Promise<TransactionWithStatus[]> = getTxWithCursor();\n    let index = 0;\n    let skippedCount = 0;\n    while (true) {\n      if (this.queries.skip && skippedCount < this.queries.skip) {\n        skippedCount++;\n      } else {\n        counter += 1;\n      }\n      index++;\n      //reset index and exchange `txs` and `buffer` after count last tx\n      if (index === txs.length) {\n        index = 0;\n        txs = await buffer;\n        // break if can not get more txs\n        if (txs.length === 0) {\n          break;\n        }\n        buffer = getTxWithCursor();\n      }\n    }\n    return counter;\n  }\n  async getTransactionHashes(): Promise<string[]> {\n    let lastCursor: undefined | string = undefined;\n    const getTxWithCursor = async (): Promise<TransactionWithStatus[]> => {\n      const result: GetTransactionDetailResult = await this.getTransactions(\n        lastCursor\n      );\n      lastCursor = result.lastCursor;\n      return result.objects;\n    };\n\n    const transactionHashes: string[] = [];\n    //skip query result in first query\n    let txs: TransactionWithStatus[] = await getTxWithCursor();\n    if (txs.length === 0) {\n      return [];\n    }\n    let buffer: Promise<TransactionWithStatus[]> = getTxWithCursor();\n    let index = 0;\n    let skippedCount = 0;\n    while (true) {\n      if (this.queries.skip && skippedCount < this.queries.skip) {\n        skippedCount++;\n      } else {\n        if (txs[index].transaction.hash) {\n          transactionHashes.push(txs[index].transaction.hash as string);\n        }\n      }\n\n      index++;\n      //reset index and exchange `txs` and `buffer` after count last tx\n      if (index === txs.length) {\n        index = 0;\n        txs = await buffer;\n        // break if can not get more txs\n        if (txs.length === 0) {\n          break;\n        }\n        buffer = getTxWithCursor();\n      }\n    }\n    return transactionHashes;\n  }\n  async *collect(): AsyncGenerator<\n    TransactionWithStatus | Transaction,\n    undefined,\n    unknown\n  > {\n    let lastCursor: undefined | string = undefined;\n    const getTxWithCursor = async (): Promise<TransactionWithStatus[]> => {\n      const result: GetTransactionDetailResult = await this.getTransactions(\n        lastCursor\n      );\n      lastCursor = result.lastCursor;\n      return result.objects;\n    };\n    //skip query result in first query\n    let txs: TransactionWithStatus[] = await getTxWithCursor();\n    if (txs.length === 0) {\n      return undefined;\n    }\n    let buffer: Promise<TransactionWithStatus[]> = getTxWithCursor();\n    let index = 0;\n    let skippedCount = 0;\n    while (true) {\n      if (this.queries.skip && skippedCount < this.queries.skip) {\n        skippedCount++;\n      } else {\n        if (this.filterOptions.includeStatus) {\n          yield txs[index];\n        } else {\n          yield txs[index].transaction;\n        }\n      }\n      index++;\n      //reset index and exchange `txs` and `buffer` after count last tx\n      if (index === txs.length) {\n        index = 0;\n        txs = await buffer;\n        // break if can not get more txs\n        if (txs.length === 0) {\n          break;\n        }\n        buffer = getTxWithCursor();\n      }\n    }\n  }\n}\n"],"mappings":"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"}