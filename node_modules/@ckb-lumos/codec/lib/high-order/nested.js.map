{"version":3,"file":"nested.js","names":["_utils","require","_error","createNullableCodec","codec","pack","packable","trackCodeExecuteError","CODEC_OPTIONAL_PATH","unpack","unpackable","createObjectCodec","codecShape","codecEntries","Object","entries","packableObj","result","forEach","key","itemCodec","assign","unpackableObj","createArrayCodec","items","map","item","index","enhancePack","afterCodecPack","beforeCodecUnpack"],"sources":["../../src/high-order/nested.ts"],"sourcesContent":["import {\n  AnyCodec,\n  Codec,\n  PackParam,\n  PackResult,\n  UnpackParam,\n  UnpackResult,\n} from \"../base\";\nimport { trackCodeExecuteError } from \"../utils\";\nimport { CODEC_OPTIONAL_PATH } from \"../error\";\n\nexport interface NullableCodec<C extends AnyCodec = AnyCodec> extends AnyCodec {\n  pack(packable?: PackParam<C>): PackResult<C>;\n\n  unpack(unpackable?: UnpackParam<C>): UnpackResult<C>;\n}\n\nexport function createNullableCodec<C extends AnyCodec = AnyCodec>(\n  codec: C\n): NullableCodec<C> {\n  return {\n    pack: (packable) => {\n      if (packable == null) return packable;\n      return trackCodeExecuteError(CODEC_OPTIONAL_PATH, () =>\n        codec.pack(packable)\n      );\n    },\n    unpack: (unpackable) => {\n      if (unpackable == null) return unpackable;\n      return codec.unpack(unpackable);\n    },\n  };\n}\n\ntype ObjectCodecShape = Record<string, AnyCodec>;\nexport type ObjectCodec<Shape extends ObjectCodecShape = ObjectCodecShape> =\n  Codec<\n    { [key in keyof Shape]: PackResult<Shape[key]> },\n    { [key in keyof Shape]: UnpackResult<Shape[key]> },\n    { [key in keyof Shape]: PackParam<Shape[key]> },\n    { [key in keyof Shape]: UnpackParam<Shape[key]> }\n  >;\n\n/**\n * a high-order codec that helps to organize multiple codecs together into a single object\n * @param codecShape\n * @example\n * ```ts\n * const codec = createObjectCodec({\n *   r: Uint8,\n *   g: Uint8,\n *   b: Uint8,\n * });\n *\n * // { r: ArrayBuffer([0xff]), g: ArrayBuffer([0x00]), b: ArrayBuffer([0x00]) }\n * codec.pack({ r: 255, g: 0, b: 0 });\n * ```\n */\nexport function createObjectCodec<Shape extends ObjectCodecShape>(\n  codecShape: Shape\n): ObjectCodec<Shape> {\n  const codecEntries = Object.entries(codecShape);\n\n  return {\n    pack: (packableObj) => {\n      const result = {} as { [key in keyof Shape]: PackResult<Shape[key]> };\n\n      codecEntries.forEach(([key, itemCodec]) => {\n        Object.assign(result, {\n          [key]: trackCodeExecuteError(key, () =>\n            itemCodec.pack(packableObj[key])\n          ),\n        });\n      });\n\n      return result;\n    },\n    unpack: (unpackableObj) => {\n      const result = {} as { [key in keyof Shape]: UnpackResult<Shape[key]> };\n\n      codecEntries.forEach(([key, itemCodec]) => {\n        Object.assign(result, { [key]: itemCodec.unpack(unpackableObj[key]) });\n      });\n\n      return result;\n    },\n  };\n}\n\nexport type ArrayCodec<C extends AnyCodec> = Codec<\n  PackResult<C>[],\n  UnpackResult<C>[],\n  PackParam<C>[],\n  UnpackParam<C>[]\n>;\n\nexport function createArrayCodec<C extends AnyCodec>(codec: C): ArrayCodec<C> {\n  return {\n    pack: (items) =>\n      items.map((item, index) =>\n        trackCodeExecuteError(index, () => codec.pack(item))\n      ),\n    unpack: (items) => items.map((item) => codec.unpack(item)),\n  };\n}\n\n/**\n * @param codec\n * @param afterCodecPack\n * @param beforeCodecUnpack\n */\nexport function enhancePack<C extends AnyCodec, Packed>(\n  codec: C,\n  afterCodecPack: (arg: PackResult<C>) => Packed,\n  beforeCodecUnpack: (arg: Packed) => UnpackParam<C>\n): Codec<Packed, UnpackResult<C>, PackParam<C>> {\n  return {\n    pack: (packable) => afterCodecPack(codec.pack(packable)),\n    unpack: (unpackable) => codec.unpack(beforeCodecUnpack(unpackable)),\n  };\n}\n"],"mappings":";;;;;;;;;AAQA,IAAAA,MAAA,GAAAC,OAAA;AACA,IAAAC,MAAA,GAAAD,OAAA;AAQO,SAASE,mBAAmBA,CACjCC,KAAQ,EACU;EAClB,OAAO;IACLC,IAAI,EAAGC,QAAQ,IAAK;MAClB,IAAIA,QAAQ,IAAI,IAAI,EAAE,OAAOA,QAAQ;MACrC,OAAO,IAAAC,4BAAqB,EAACC,0BAAmB,EAAE,MAChDJ,KAAK,CAACC,IAAI,CAACC,QAAQ,CACrB,CAAC;IACH,CAAC;IACDG,MAAM,EAAGC,UAAU,IAAK;MACtB,IAAIA,UAAU,IAAI,IAAI,EAAE,OAAOA,UAAU;MACzC,OAAON,KAAK,CAACK,MAAM,CAACC,UAAU,CAAC;IACjC;EACF,CAAC;AACH;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASC,iBAAiBA,CAC/BC,UAAiB,EACG;EACpB,MAAMC,YAAY,GAAGC,MAAM,CAACC,OAAO,CAACH,UAAU,CAAC;EAE/C,OAAO;IACLP,IAAI,EAAGW,WAAW,IAAK;MACrB,MAAMC,MAAM,GAAG,CAAC,CAAqD;MAErEJ,YAAY,CAACK,OAAO,CAAC,CAAC,CAACC,GAAG,EAAEC,SAAS,CAAC,KAAK;QACzCN,MAAM,CAACO,MAAM,CAACJ,MAAM,EAAE;UACpB,CAACE,GAAG,GAAG,IAAAZ,4BAAqB,EAACY,GAAG,EAAE,MAChCC,SAAS,CAACf,IAAI,CAACW,WAAW,CAACG,GAAG,CAAC,CACjC;QACF,CAAC,CAAC;MACJ,CAAC,CAAC;MAEF,OAAOF,MAAM;IACf,CAAC;IACDR,MAAM,EAAGa,aAAa,IAAK;MACzB,MAAML,MAAM,GAAG,CAAC,CAAuD;MAEvEJ,YAAY,CAACK,OAAO,CAAC,CAAC,CAACC,GAAG,EAAEC,SAAS,CAAC,KAAK;QACzCN,MAAM,CAACO,MAAM,CAACJ,MAAM,EAAE;UAAE,CAACE,GAAG,GAAGC,SAAS,CAACX,MAAM,CAACa,aAAa,CAACH,GAAG,CAAC;QAAE,CAAC,CAAC;MACxE,CAAC,CAAC;MAEF,OAAOF,MAAM;IACf;EACF,CAAC;AACH;AASO,SAASM,gBAAgBA,CAAqBnB,KAAQ,EAAiB;EAC5E,OAAO;IACLC,IAAI,EAAGmB,KAAK,IACVA,KAAK,CAACC,GAAG,CAAC,CAACC,IAAI,EAAEC,KAAK,KACpB,IAAApB,4BAAqB,EAACoB,KAAK,EAAE,MAAMvB,KAAK,CAACC,IAAI,CAACqB,IAAI,CAAC,CACrD,CAAC;IACHjB,MAAM,EAAGe,KAAK,IAAKA,KAAK,CAACC,GAAG,CAAEC,IAAI,IAAKtB,KAAK,CAACK,MAAM,CAACiB,IAAI,CAAC;EAC3D,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACO,SAASE,WAAWA,CACzBxB,KAAQ,EACRyB,cAA8C,EAC9CC,iBAAkD,EACJ;EAC9C,OAAO;IACLzB,IAAI,EAAGC,QAAQ,IAAKuB,cAAc,CAACzB,KAAK,CAACC,IAAI,CAACC,QAAQ,CAAC,CAAC;IACxDG,MAAM,EAAGC,UAAU,IAAKN,KAAK,CAACK,MAAM,CAACqB,iBAAiB,CAACpB,UAAU,CAAC;EACpE,CAAC;AACH"}