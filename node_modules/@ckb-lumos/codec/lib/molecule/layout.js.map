{"version":3,"file":"layout.js","names":["_base","require","_number","_bytes","_error","_highOrder","array","itemCodec","itemCount","enhancedArrayCodec","createArrayCodec","createFixedBytesCodec","byteLength","pack","items","itemsBuf","concat","unpack","buf","result","itemLength","offset","push","slice","diff","x1","x2","filter","x","includes","checkShape","shape","fields","shapeKeys","Object","keys","missingFields","missingShape","length","Error","join","struct","objectCodec","createObjectCodec","reduce","sum","field","obj","packed","Uint8Array","from","forEach","itemBuf","assign","fixvec","createBytesCodec","arrayCodec","Uint32LE","item","ArrayBuffer","dynvec","packedHeader","header","body","packedTotalSize","totalSize","offset0","offsets","Array","fill","map","_","index","start","end","vector","isFixedCodec","table","headerLength","packedObj","packedItem","packedOffset","union","type","typeName","CodecBaseParseError","fieldIndex","indexOf","String","packedFieldIndex","packedBody","value","typeIndex","option","nullableCodec","createNullableCodec","undefined"],"sources":["../../src/molecule/layout.ts"],"sourcesContent":["/**\n * |  Type  |                      Header                      |               Body                |\n * |--------+--------------------------------------------------+-----------------------------------|\n * | array  |                                                  |  item-0 |  item-1 | ... |  item-N |\n * | struct |                                                  | field-0 | field-1 | ... | field-N |\n * | fixvec | items-count                                      |  item-0 |  item-1 | ... |  item-N |\n * | dynvec | full-size | offset-0 | offset-1 | ... | offset-N |  item-0 |  item-1 | ... |  item-N |\n * | table  | full-size | offset-0 | offset-1 | ... | offset-N | filed-0 | field-1 | ... | field-N |\n * | option |                                                  | item or none (zero bytes)         |\n * | union  | item-type-id                                     | item                              |\n */\n\nimport {\n  BytesCodec,\n  Fixed,\n  FixedBytesCodec,\n  PackParam,\n  UnpackResult,\n  createBytesCodec,\n  createFixedBytesCodec,\n  isFixedCodec,\n} from \"../base\";\nimport { Uint32LE } from \"../number\";\nimport { concat } from \"../bytes\";\nimport { CodecBaseParseError } from \"../error\";\nimport {\n  createObjectCodec,\n  createArrayCodec,\n  createNullableCodec,\n} from \"../high-order\";\n\ntype NullableKeys<O extends Record<string, unknown>> = {\n  [K in keyof O]-?: [O[K] & (undefined | null)] extends [never] ? never : K;\n}[keyof O];\ntype NonNullableKeys<O extends Record<string, unknown>> = {\n  [K in keyof O]-?: [O[K] & (undefined | null)] extends [never] ? K : never;\n}[keyof O];\n\n// prettier-ignore\ntype PartialNullable<O extends Record<string, unknown>> =\n  & Partial<Pick<O, NullableKeys<O>>>\n  & Pick<O, NonNullableKeys<O>>;\n\nexport type ObjectCodec<T extends Record<string, BytesCodec>> = BytesCodec<\n  PartialNullable<{ [key in keyof T]: UnpackResult<T[key]> }>,\n  PartialNullable<{ [key in keyof T]: PackParam<T[key]> }>\n>;\n\nexport interface OptionCodec<T extends BytesCodec>\n  extends BytesCodec<UnpackResult<T> | undefined> {\n  pack: (packable?: PackParam<T>) => Uint8Array;\n}\n\nexport type ArrayCodec<T extends BytesCodec> = BytesCodec<\n  Array<UnpackResult<T>>,\n  Array<PackParam<T>>\n>;\n\nexport type UnionCodec<T extends Record<string, BytesCodec>> = BytesCodec<\n  { [key in keyof T]: { type: key; value: UnpackResult<T[key]> } }[keyof T],\n  { [key in keyof T]: { type: key; value: PackParam<T[key]> } }[keyof T]\n>;\n\n/**\n * The array is a fixed-size type: it has a fixed-size inner type and a fixed length.\n * The size of an array is the size of inner type times the length.\n * @param itemCodec the fixed-size array item codec\n * @param itemCount\n */\nexport function array<T extends FixedBytesCodec>(\n  itemCodec: T,\n  itemCount: number\n): ArrayCodec<T> & Fixed {\n  const enhancedArrayCodec = createArrayCodec(itemCodec);\n  return createFixedBytesCodec({\n    byteLength: itemCodec.byteLength * itemCount,\n    pack(items) {\n      const itemsBuf = enhancedArrayCodec.pack(items);\n      return concat(...itemsBuf);\n    },\n    unpack(buf) {\n      const result: UnpackResult<T>[] = [];\n      const itemLength = itemCodec.byteLength;\n      for (let offset = 0; offset < buf.byteLength; offset += itemLength) {\n        result.push(itemCodec.unpack(buf.slice(offset, offset + itemLength)));\n      }\n      return result;\n    },\n  });\n}\n\nfunction diff(x1: unknown[], x2: unknown[]) {\n  return x1.filter((x) => !x2.includes(x));\n}\n\nfunction checkShape<T extends object>(shape: T, fields: (keyof T)[]) {\n  const shapeKeys = Object.keys(shape) as (keyof T)[];\n\n  const missingFields = diff(shapeKeys, fields);\n  const missingShape = diff(fields, shapeKeys);\n\n  if (missingFields.length > 0 || missingShape.length > 0) {\n    throw new Error(\n      `Invalid shape: missing fields ${missingFields.join(\n        \", \"\n      )} or shape ${missingShape.join(\", \")}`\n    );\n  }\n}\n\n/**\n * Struct is a fixed-size type: all fields in struct are fixed-size and it has a fixed quantity of fields.\n * The size of a struct is the sum of all fields' size.\n * @param shape a object contains all fields' codec\n * @param fields the shape's keys. It provide an order for serialization/deserialization.\n */\nexport function struct<T extends Record<string, FixedBytesCodec>>(\n  shape: T,\n  fields: (keyof T)[]\n): ObjectCodec<T> & Fixed {\n  checkShape(shape, fields);\n  const objectCodec = createObjectCodec(shape);\n  return createFixedBytesCodec({\n    byteLength: fields.reduce((sum, field) => sum + shape[field].byteLength, 0),\n    pack(obj) {\n      const packed = objectCodec.pack(\n        obj as { [K in keyof T]: PackParam<T[K]> }\n      );\n      return fields.reduce((result, field) => {\n        return concat(result, packed[field]);\n      }, Uint8Array.from([]));\n    },\n    unpack(buf) {\n      const result = {} as PartialNullable<\n        {\n          [key in keyof T]: UnpackResult<T[key]>;\n        }\n      >;\n      let offset = 0;\n\n      fields.forEach((field) => {\n        const itemCodec = shape[field];\n        const itemBuf = buf.slice(offset, offset + itemCodec.byteLength);\n        Object.assign(result, { [field]: itemCodec.unpack(itemBuf) });\n\n        offset = offset + itemCodec.byteLength;\n      });\n\n      return result;\n    },\n  });\n}\n\n/**\n * Vector with fixed size item codec\n * @param itemCodec fixed-size vector item codec\n */\nexport function fixvec<T extends FixedBytesCodec>(itemCodec: T): ArrayCodec<T> {\n  return createBytesCodec({\n    pack(items) {\n      const arrayCodec = createArrayCodec(itemCodec);\n      return concat(\n        Uint32LE.pack(items.length),\n        arrayCodec\n          .pack(items)\n          .reduce((buf, item) => concat(buf, item), new ArrayBuffer(0))\n      );\n    },\n    unpack(buf) {\n      if (buf.byteLength < 4) {\n        throw new Error(\n          `fixvec: buffer is too short, expected at least 4 bytes, got ${buf.byteLength}`\n        );\n      }\n      const itemCount = Uint32LE.unpack(buf.slice(0, 4));\n      return array(itemCodec, itemCount).unpack(buf.slice(4));\n    },\n  });\n}\n\n/**\n * Vector with dynamic size item codec\n * @param itemCodec the vector item codec. It can be fixed-size or dynamic-size.\n * For example, you can create a recursive vector with this.\n */\nexport function dynvec<T extends BytesCodec>(itemCodec: T): ArrayCodec<T> {\n  return createBytesCodec({\n    pack(obj) {\n      const arrayCodec = createArrayCodec(itemCodec);\n      const packed = arrayCodec.pack(obj).reduce(\n        (result, item) => {\n          const packedHeader = Uint32LE.pack(result.offset);\n          return {\n            header: concat(result.header, packedHeader),\n            body: concat(result.body, item),\n            offset: result.offset + item.byteLength,\n          };\n        },\n        {\n          header: new ArrayBuffer(0),\n          body: new ArrayBuffer(0),\n          offset: 4 + obj.length * 4,\n        }\n      );\n      const packedTotalSize = Uint32LE.pack(\n        packed.header.byteLength + packed.body.byteLength + 4\n      );\n      return concat(packedTotalSize, packed.header, packed.body);\n    },\n    unpack(buf) {\n      const totalSize = Uint32LE.unpack(buf.slice(0, 4));\n      if (totalSize !== buf.byteLength) {\n        throw new Error(\n          `Invalid buffer size, read from header: ${totalSize}, actual: ${buf.byteLength}`\n        );\n      }\n      const result: UnpackResult<T>[] = [];\n      if (totalSize <= 4) {\n        return result;\n      } else {\n        const offset0 = Uint32LE.unpack(buf.slice(4, 8));\n        const itemCount = (offset0 - 4) / 4;\n        const offsets = new Array(itemCount)\n          .fill(1)\n          .map((_, index) =>\n            Uint32LE.unpack(buf.slice(4 + index * 4, 8 + index * 4))\n          );\n        offsets.push(totalSize);\n        const result: UnpackResult<T>[] = [];\n        for (let index = 0; index < offsets.length - 1; index++) {\n          const start = offsets[index];\n          const end = offsets[index + 1];\n          const itemBuf = buf.slice(start, end);\n          result.push(itemCodec.unpack(itemBuf));\n        }\n        return result;\n      }\n    },\n  });\n}\n\n/**\n * General vector codec, if `itemCodec` is fixed size type, it will create a fixvec codec, otherwise a dynvec codec will be created.\n * @param itemCodec\n */\nexport function vector<T extends BytesCodec>(itemCodec: T): ArrayCodec<T> {\n  if (isFixedCodec(itemCodec)) {\n    return fixvec(itemCodec);\n  }\n  return dynvec(itemCodec);\n}\n\n/**\n * Table is a dynamic-size type. It can be considered as a dynvec but the length is fixed.\n * @param shape The table shape, item codec can be dynamic size\n * @param fields the shape's keys. Also provide an order for pack/unpack.\n */\nexport function table<T extends Record<string, BytesCodec>>(\n  shape: T,\n  fields: (keyof T)[]\n): ObjectCodec<T> {\n  checkShape(shape, fields);\n  return createBytesCodec({\n    pack(obj) {\n      const headerLength = 4 + fields.length * 4;\n      const objectCodec = createObjectCodec(shape);\n      const packedObj = objectCodec.pack(\n        obj as { [K in keyof T]: PackParam<T[K]> }\n      );\n      const packed = fields.reduce(\n        (result, field) => {\n          const packedItem = packedObj[field];\n          const packedOffset = Uint32LE.pack(result.offset);\n          return {\n            header: concat(result.header, packedOffset),\n            body: concat(result.body, packedItem),\n            offset: result.offset + packedItem.byteLength,\n          };\n        },\n        {\n          header: new ArrayBuffer(0),\n          body: new ArrayBuffer(0),\n          offset: headerLength,\n        }\n      );\n      const packedTotalSize = Uint32LE.pack(\n        packed.header.byteLength + packed.body.byteLength + 4\n      );\n      return concat(packedTotalSize, packed.header, packed.body);\n    },\n    unpack(buf) {\n      const totalSize = Uint32LE.unpack(buf.slice(0, 4));\n      if (totalSize !== buf.byteLength) {\n        throw new Error(\n          `Invalid buffer size, read from header: ${totalSize}, actual: ${buf.byteLength}`\n        );\n      }\n      if (totalSize <= 4 || fields.length === 0) {\n        return {} as PartialNullable<\n          {\n            [key in keyof T]: UnpackResult<T[key]>;\n          }\n        >;\n      } else {\n        const offsets = fields.map((_, index) =>\n          Uint32LE.unpack(buf.slice(4 + index * 4, 8 + index * 4))\n        );\n        offsets.push(totalSize);\n        const obj = {};\n        for (let index = 0; index < offsets.length - 1; index++) {\n          const start = offsets[index];\n          const end = offsets[index + 1];\n          const field = fields[index];\n          const itemCodec = shape[field];\n          const itemBuf = buf.slice(start, end);\n          Object.assign(obj, { [field]: itemCodec.unpack(itemBuf) });\n        }\n        return obj as PartialNullable<\n          {\n            [key in keyof T]: UnpackResult<T[key]>;\n          }\n        >;\n      }\n    },\n  });\n}\n\n/**\n * Union is a dynamic-size type.\n * Serializing a union has two steps:\n * - Serialize a item type id in bytes as a 32 bit unsigned integer in little-endian. The item type id is the index of the inner items, and it's starting at 0.\n * - Serialize the inner item.\n * @param itemCodec the union item record\n * @param fields the list of itemCodec's keys. It's also provide an order for pack/unpack.\n */\nexport function union<T extends Record<string, BytesCodec>>(\n  itemCodec: T,\n  fields: (keyof T)[]\n): UnionCodec<T> {\n  return createBytesCodec({\n    pack(obj) {\n      const type = obj.type;\n      const typeName = `Union(${fields.join(\" | \")})`;\n\n      /* c8 ignore next */\n      if (typeof type !== \"string\") {\n        throw new CodecBaseParseError(\n          `Invalid type in union, type must be a string`,\n          typeName\n        );\n      }\n\n      const fieldIndex = fields.indexOf(type);\n      if (fieldIndex === -1) {\n        throw new CodecBaseParseError(\n          `Unknown union type: ${String(obj.type)}`,\n          typeName\n        );\n      }\n      const packedFieldIndex = Uint32LE.pack(fieldIndex);\n      const packedBody = itemCodec[type].pack(obj.value);\n      return concat(packedFieldIndex, packedBody);\n    },\n    unpack(buf) {\n      const typeIndex = Uint32LE.unpack(buf.slice(0, 4));\n      const type = fields[typeIndex];\n      return { type, value: itemCodec[type].unpack(buf.slice(4)) };\n    },\n  });\n}\n\n/**\n * Option is a dynamic-size type.\n * Serializing an option depends on whether it is empty or not:\n * - if it's empty, there is zero bytes (the size is 0).\n * - if it's not empty, just serialize the inner item (the size is same as the inner item's size).\n * @param itemCodec\n */\nexport function option<T extends BytesCodec>(itemCodec: T): OptionCodec<T> {\n  return createBytesCodec({\n    pack(obj?) {\n      const nullableCodec = createNullableCodec(itemCodec);\n      if (obj !== undefined && obj !== null) {\n        return nullableCodec.pack(obj);\n      } else {\n        return Uint8Array.from([]);\n      }\n    },\n    unpack(buf) {\n      if (buf.byteLength === 0) {\n        return undefined;\n      }\n      return itemCodec.unpack(buf);\n    },\n  });\n}\n"],"mappings":"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"}