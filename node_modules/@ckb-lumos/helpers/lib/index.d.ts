import { Address, Cell, CellDep, CellProvider, Hash, HexString, PackedSince, Script, Transaction, OutPoint } from "@ckb-lumos/base";
import { List, Map as ImmutableMap, Record } from "immutable";
import { Config, predefined } from "@ckb-lumos/config-manager";
import { BI } from "@ckb-lumos/bi";
export interface Options {
    config?: Config;
}
export declare function minimalScriptCapacity(script: Script, { validate }?: {
    validate?: boolean;
}): bigint;
export declare function minimalScriptCapacityCompatible(script: Script, { validate }?: {
    validate?: boolean;
}): BI;
export declare function minimalCellCapacity(fullCell: Cell, { validate }?: {
    validate?: boolean;
}): bigint;
export declare function minimalCellCapacityCompatible(fullCell: Cell, { validate }?: {
    validate?: boolean;
}): BI;
export declare function locateCellDep(script: Script, { config }?: Options): CellDep | null;
/**
 * @deprecated please migrate to {@link encodeToAddress}, the short format address will be removed in the future
 * @param script
 * @param param1
 * @returns
 */
export declare function generateAddress(script: Script, { config }?: Options): Address;
/**
 * @deprecated please migrate to {@link encodeToAddress}, the short format address will be removed in the future */
export declare const scriptToAddress: typeof generateAddress;
/**
 * @deprecated please migrate to {@link encodeToConfigAddress}
 * @param args
 * @param param1
 * @returns
 */
export declare function generateSecp256k1Blake160Address(args: HexString, { config }?: Options): Address;
/**
 * @deprecated please migrate to {@link encodeToConfigAddress}
 * @param args
 * @param config
 */
export declare function generateSecp256k1Blake160MultisigAddress(args: HexString, { config }?: Options): Address;
export declare function parseAddress(address: Address, { config }?: Options): Script;
export declare const addressToScript: typeof parseAddress;
/**
 * parse a lock script to an address
 * @param script
 * @param config
 */
export declare function encodeToAddress(script: Script, { config }?: Options): Address;
type PredefinedScriptName = keyof typeof predefined.LINA.SCRIPTS;
export declare function encodeToConfigAddress(args: HexString, scriptType: PredefinedScriptName): string;
export declare function encodeToConfigAddress<C extends Config>(args: HexString, scriptType: keyof C["SCRIPTS"], options: {
    config?: C;
}): string;
export interface TransactionSkeletonInterface {
    cellProvider: CellProvider | null;
    cellDeps: List<CellDep>;
    headerDeps: List<Hash>;
    inputs: List<Cell>;
    outputs: List<Cell>;
    witnesses: List<HexString>;
    fixedEntries: List<{
        field: string;
        index: number;
    }>;
    signingEntries: List<{
        type: string;
        index: number;
        message: string;
    }>;
    inputSinces: ImmutableMap<number, PackedSince>;
}
export type TransactionSkeletonType = Record<TransactionSkeletonInterface> & Readonly<TransactionSkeletonInterface>;
export declare const TransactionSkeleton: Record.Factory<TransactionSkeletonInterface>;
export declare function createTransactionFromSkeleton(txSkeleton: TransactionSkeletonType, { validate }?: {
    validate?: boolean;
}): Transaction;
type Promisable<T> = Promise<T> | T;
export type LiveCellFetcher = (outPoint: OutPoint) => Promisable<Cell>;
/**
 * create a {@link TransactionSkeleton} from a {@link Transaction}
 * @example
 * ```js
 * const rpc = new RPC('localhost:8114')
 * const fetcher = (outPoint: OutPoint) => rpc.getLiveCell(outPoint)
 * const skeleton = await createTransactionSkeleton({ transaction, fetcher });
 * ```
 */
export declare function createTransactionSkeleton(transaction: Transaction, fetcher: LiveCellFetcher): Promise<TransactionSkeletonType>;
export declare function sealTransaction(txSkeleton: TransactionSkeletonType, sealingContents: HexString[]): Transaction;
export interface TransactionSkeletonObject {
    cellProvider: CellProvider | null;
    cellDeps: CellDep[];
    headerDeps: Hash[];
    inputs: Cell[];
    outputs: Cell[];
    witnesses: HexString[];
    fixedEntries: Array<{
        field: string;
        index: number;
    }>;
    signingEntries: Array<{
        type: string;
        index: number;
        message: string;
    }>;
    inputSinces: Map<number, PackedSince>;
}
/**
 * Convert TransactionSkeleton to js object
 *
 * @param txSkelton
 */
export declare function transactionSkeletonToObject(txSkelton: TransactionSkeletonType): TransactionSkeletonObject;
/**
 * Convert js object to TransactionSkeleton
 *
 * @param obj
 */
export declare function objectToTransactionSkeleton(obj: TransactionSkeletonObject): TransactionSkeletonType;
export {};
//# sourceMappingURL=index.d.ts.map