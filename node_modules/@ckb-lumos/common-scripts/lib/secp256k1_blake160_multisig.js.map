{"version":3,"file":"secp256k1_blake160_multisig.js","names":["_helpers","require","_codec","_base","_configManager","_immutable","_helper","_from_info","_bi","ScriptValue","values","CellCollector","constructor","fromInfo","cellProvider","config","undefined","queryOptions","Error","getConfig","result","parseFromInfo","fromScript","multisigScript","lock","type","cellCollector","collector","collect","isSecp256k1Blake160MultisigScript","inputCell","exports","setupInputCell","txSkeleton","defaultWitness","since","requireMultisigScript","cellOutput","parsedFromScript","validate","equals","update","inputs","push","inputSinces","set","get","size","witnesses","outputCell","capacity","data","outputs","template","SCRIPTS","SECP256K1_BLAKE160_MULTISIG","scriptOutPoint","txHash","TX_HASH","index","INDEX","addCellDep","outPoint","depType","DEP_TYPE","firstIndex","findIndex","input","firstIndexWitness","witness","newWitnessArgs","slice","SECP_SIGNATURE_PLACEHOLDER","repeat","M","witnessArgs","blockchain","WitnessArgs","unpack","bytes","bytify","equal","inputType","outputType","hexify","pack","transfer","toAddress","amount","requireToAddress","assertAmountEnough","transferCompatible","_txSkeleton","_amount","Array","BigInt","toString","ensureScript","noMultisigBefore","find","i","BI","from","toScript","parseAddress","blockHash","lastFreezedOutput","filter","field","maxBy","gt","output","cellCapacity","deductCapacity","gte","sub","minimalCellCapacityCompatible","eq","changeCell","changeCapacity","previousInputs","Set","add","has","inputCapacity","payFee","injectCapacity","outputIndex","prepareSigningEntries","_prepareSigningEntries","_default","serializeMultisigScript","multisigArgs","default"],"sources":["../src/secp256k1_blake160_multisig.ts"],"sourcesContent":["import {\n  parseAddress,\n  TransactionSkeletonType,\n  Options,\n  minimalCellCapacityCompatible,\n} from \"@ckb-lumos/helpers\";\nimport { bytes } from \"@ckb-lumos/codec\";\nimport {\n  values,\n  HexString,\n  Script,\n  Address,\n  OutPoint,\n  Cell,\n  WitnessArgs,\n  CellCollector as CellCollectorType,\n  CellProvider,\n  QueryOptions,\n  PackedSince,\n  blockchain,\n} from \"@ckb-lumos/base\";\nimport { getConfig, Config } from \"@ckb-lumos/config-manager\";\nconst { ScriptValue } = values;\nimport { Set } from \"immutable\";\nimport {\n  addCellDep,\n  ensureScript,\n  SECP_SIGNATURE_PLACEHOLDER,\n  prepareSigningEntries as _prepareSigningEntries,\n  isSecp256k1Blake160MultisigScript,\n} from \"./helper\";\nimport {\n  FromInfo,\n  parseFromInfo,\n  MultisigScript,\n  serializeMultisigScript,\n  multisigArgs,\n} from \"./from_info\";\nimport { BI, BIish } from \"@ckb-lumos/bi\";\nimport { CellCollectorConstructor } from \"./type\";\n\nexport { serializeMultisigScript, multisigArgs };\n\nexport const CellCollector: CellCollectorConstructor = class CellCollector\n  implements CellCollectorType\n{\n  private cellCollector: CellCollectorType;\n  private config: Config;\n  public readonly fromScript: Script;\n  public readonly multisigScript?: HexString;\n\n  constructor(\n    fromInfo: FromInfo,\n    cellProvider: CellProvider,\n    {\n      config = undefined,\n      queryOptions = {},\n    }: Options & {\n      queryOptions?: QueryOptions;\n    } = {}\n  ) {\n    if (!cellProvider) {\n      throw new Error(`Cell provider is missing!`);\n    }\n    config = config || getConfig();\n    const result = parseFromInfo(fromInfo, { config });\n    this.fromScript = result.fromScript;\n    this.multisigScript = result.multisigScript;\n\n    this.config = config;\n\n    queryOptions = {\n      ...queryOptions,\n      lock: this.fromScript,\n      type: queryOptions.type || \"empty\",\n    };\n\n    this.cellCollector = cellProvider.collector(queryOptions);\n  }\n\n  async *collect(): AsyncGenerator<Cell> {\n    if (!isSecp256k1Blake160MultisigScript(this.fromScript, this.config)) {\n      return;\n    }\n\n    for await (const inputCell of this.cellCollector.collect()) {\n      yield inputCell;\n    }\n  }\n};\n\n/**\n * Setup input cell infos, such as cell deps and witnesses.\n *\n * @param txSkeleton\n * @param inputCell\n * @param fromInfo\n * @param options\n */\nexport async function setupInputCell(\n  txSkeleton: TransactionSkeletonType,\n  inputCell: Cell,\n  fromInfo?: FromInfo,\n  {\n    config = undefined,\n    defaultWitness = \"0x\",\n    since = undefined,\n    requireMultisigScript = true,\n  }: Options & {\n    defaultWitness?: HexString;\n    requireMultisigScript?: boolean;\n    since?: PackedSince;\n  } = {}\n): Promise<TransactionSkeletonType> {\n  config = config || getConfig();\n\n  if (requireMultisigScript && typeof fromInfo !== \"object\") {\n    throw new Error(\"`fromInfo` must be MultisigScript format!\");\n  }\n\n  const fromScript: Script = inputCell.cellOutput.lock;\n\n  if (fromInfo) {\n    const parsedFromScript: Script = parseFromInfo(fromInfo, {\n      config,\n    }).fromScript;\n    if (\n      !new ScriptValue(parsedFromScript, { validate: false }).equals(\n        new ScriptValue(fromScript, { validate: false })\n      )\n    ) {\n      throw new Error(\"`fromInfo` not match to input lock!\");\n    }\n  }\n\n  if (!isSecp256k1Blake160MultisigScript(fromScript, config)) {\n    throw new Error(`Not SECP256K1_BLAKE160_MULTISIG input!`);\n  }\n\n  // add inputCell to txSkeleton\n  txSkeleton = txSkeleton.update(\"inputs\", (inputs) => {\n    return inputs.push(inputCell);\n  });\n\n  if (since) {\n    txSkeleton = txSkeleton.update(\"inputSinces\", (inputSinces) => {\n      return inputSinces.set(txSkeleton.get(\"inputs\").size - 1, since);\n    });\n  }\n\n  txSkeleton = txSkeleton.update(\"witnesses\", (witnesses) => {\n    return witnesses.push(defaultWitness);\n  });\n\n  const outputCell: Cell = {\n    cellOutput: {\n      capacity: inputCell.cellOutput.capacity,\n      lock: inputCell.cellOutput.lock,\n      type: inputCell.cellOutput.type,\n    },\n    data: inputCell.data,\n  };\n\n  txSkeleton = txSkeleton.update(\"outputs\", (outputs) => {\n    return outputs.push(outputCell);\n  });\n\n  const template = config.SCRIPTS.SECP256K1_BLAKE160_MULTISIG;\n  if (!template) {\n    throw new Error(\n      `SECP256K1_BLAKE160_MULTISIG script not defined in config!`\n    );\n  }\n\n  const scriptOutPoint: OutPoint = {\n    txHash: template.TX_HASH,\n    index: template.INDEX,\n  };\n\n  // add cell dep\n  txSkeleton = addCellDep(txSkeleton, {\n    outPoint: scriptOutPoint,\n    depType: template.DEP_TYPE,\n  });\n\n  // add witness\n  const firstIndex = txSkeleton\n    .get(\"inputs\")\n    .findIndex((input) =>\n      new ScriptValue(input.cellOutput.lock, { validate: false }).equals(\n        new ScriptValue(fromScript!, { validate: false })\n      )\n    );\n  if (firstIndex !== -1) {\n    while (firstIndex >= txSkeleton.get(\"witnesses\").size) {\n      txSkeleton = txSkeleton.update(\"witnesses\", (witnesses) =>\n        witnesses.push(\"0x\")\n      );\n    }\n\n    const firstIndexWitness = txSkeleton.get(\"witnesses\").get(firstIndex)!;\n    // If never prepared witness of this lock script before, should using fromInfo(MultisigScript) to update witness\n    if (firstIndexWitness === \"0x\" && typeof fromInfo !== \"object\") {\n      throw new Error(\"`fromInfo` must be MultisigScript format!\");\n    }\n\n    // if using MultisigScript, check witnesses\n    if (typeof fromInfo === \"object\") {\n      const multisigScript: HexString = parseFromInfo(fromInfo, { config })\n        .multisigScript!;\n      let witness = txSkeleton.get(\"witnesses\").get(firstIndex)!;\n      const newWitnessArgs: WitnessArgs = {\n        lock:\n          \"0x\" +\n          multisigScript.slice(2) +\n          SECP_SIGNATURE_PLACEHOLDER.slice(2).repeat(\n            (fromInfo as MultisigScript).M\n          ),\n      };\n      if (witness !== \"0x\") {\n        const witnessArgs = blockchain.WitnessArgs.unpack(\n          bytes.bytify(witness)\n        );\n        const lock = witnessArgs.lock;\n        if (\n          !!lock &&\n          !!newWitnessArgs.lock &&\n          !bytes.equal(lock, newWitnessArgs.lock)\n        ) {\n          throw new Error(\n            \"Lock field in first witness is set aside for signature!\"\n          );\n        }\n        const inputType = witnessArgs.inputType;\n        if (inputType) {\n          newWitnessArgs.inputType = inputType;\n        }\n        const outputType = witnessArgs.outputType;\n        if (outputType) {\n          newWitnessArgs.outputType = outputType;\n        }\n      }\n      witness = bytes.hexify(blockchain.WitnessArgs.pack(newWitnessArgs));\n      txSkeleton = txSkeleton.update(\"witnesses\", (witnesses) =>\n        witnesses.set(firstIndex, witness)\n      );\n    }\n  }\n\n  return txSkeleton;\n}\n\nexport async function transfer(\n  txSkeleton: TransactionSkeletonType,\n  fromInfo: FromInfo,\n  toAddress: Address | undefined,\n  amount: bigint,\n  options?: {\n    config?: Config;\n    requireToAddress?: boolean;\n    assertAmountEnough?: true;\n  }\n): Promise<TransactionSkeletonType>;\n\nexport async function transfer(\n  txSkeleton: TransactionSkeletonType,\n  fromInfo: FromInfo,\n  toAddress: Address | undefined,\n  amount: bigint,\n  options: {\n    config?: Config;\n    requireToAddress?: boolean;\n    assertAmountEnough: false;\n  }\n): Promise<[TransactionSkeletonType, bigint]>;\n\n/**\n * transfer capacity from multisig script cells\n *\n * @param txSkeleton\n * @param fromInfo fromAddress or fromMultisigScript, if this address new to txSkeleton inputs, must use fromMultisigScript\n * @param toAddress\n * @param amount transfer CKB capacity in shannon.\n * @param options\n */\nexport async function transfer(\n  txSkeleton: TransactionSkeletonType,\n  fromInfo: FromInfo,\n  toAddress: Address | undefined,\n  amount: bigint,\n  {\n    config = undefined,\n    requireToAddress = true,\n    assertAmountEnough = true,\n  }: {\n    config?: Config;\n    requireToAddress?: boolean;\n    assertAmountEnough?: boolean;\n  } = {}\n): Promise<TransactionSkeletonType | [TransactionSkeletonType, bigint]> {\n  const result = await transferCompatible(\n    txSkeleton,\n    fromInfo,\n    toAddress,\n    amount,\n    {\n      config,\n      requireToAddress,\n      assertAmountEnough: assertAmountEnough as true | undefined,\n    }\n  );\n  let _txSkeleton: TransactionSkeletonType;\n  let _amount: bigint;\n  if (result instanceof Array) {\n    _txSkeleton = result[0];\n    _amount = BigInt(result[1].toString());\n    return [_txSkeleton, _amount];\n  } else {\n    _txSkeleton = result;\n    return _txSkeleton;\n  }\n}\nexport async function transferCompatible(\n  txSkeleton: TransactionSkeletonType,\n  fromInfo: FromInfo,\n  toAddress: Address | undefined,\n  amount: BIish,\n  options?: {\n    config?: Config;\n    requireToAddress?: boolean;\n    assertAmountEnough?: true;\n  }\n): Promise<TransactionSkeletonType>;\n\nexport async function transferCompatible(\n  txSkeleton: TransactionSkeletonType,\n  fromInfo: FromInfo,\n  toAddress: Address | undefined,\n  amount: BIish,\n  options: {\n    config?: Config;\n    requireToAddress?: boolean;\n    assertAmountEnough: false;\n  }\n): Promise<[TransactionSkeletonType, BI]>;\n\nexport async function transferCompatible(\n  txSkeleton: TransactionSkeletonType,\n  fromInfo: FromInfo,\n  toAddress: Address | undefined,\n  amount: BIish,\n  {\n    config = undefined,\n    requireToAddress = true,\n    assertAmountEnough = true,\n  }: {\n    config?: Config;\n    requireToAddress?: boolean;\n    assertAmountEnough?: boolean;\n  } = {}\n): Promise<TransactionSkeletonType | [TransactionSkeletonType, BI]> {\n  config = config || getConfig();\n  const template = config.SCRIPTS.SECP256K1_BLAKE160_MULTISIG;\n  if (!template) {\n    throw new Error(\n      \"Provided config does not have SECP256K1_BLAKE16_MULTISIG script setup!\"\n    );\n  }\n  const scriptOutPoint: OutPoint = {\n    txHash: template.TX_HASH,\n    index: template.INDEX,\n  };\n\n  txSkeleton = addCellDep(txSkeleton, {\n    outPoint: scriptOutPoint,\n    depType: template.DEP_TYPE,\n  });\n\n  const { fromScript, multisigScript } = parseFromInfo(fromInfo, { config });\n\n  ensureScript(fromScript, config, \"SECP256K1_BLAKE160_MULTISIG\");\n\n  const noMultisigBefore = !txSkeleton.get(\"inputs\").find((i) => {\n    return new ScriptValue(i.cellOutput.lock, { validate: false }).equals(\n      new ScriptValue(fromScript!, { validate: false })\n    );\n  });\n\n  if (noMultisigBefore && fromInfo === \"string\") {\n    throw new Error(\"MultisigScript is required for witness!\");\n  }\n\n  if (requireToAddress && !toAddress) {\n    throw new Error(\"You must provide a to address!\");\n  }\n\n  let _amount = amount ? BI.from(amount) : BI.from(0);\n  if (toAddress) {\n    const toScript = parseAddress(toAddress, { config });\n\n    txSkeleton = txSkeleton.update(\"outputs\", (outputs) => {\n      return outputs.push({\n        cellOutput: {\n          capacity: \"0x\" + _amount.toString(16),\n          lock: toScript,\n          type: undefined,\n        },\n        data: \"0x\",\n        outPoint: undefined,\n        blockHash: undefined,\n      });\n    });\n  }\n\n  const lastFreezedOutput = txSkeleton\n    .get(\"fixedEntries\")\n    .filter(({ field }) => field === \"outputs\")\n    .maxBy(({ index }) => index);\n  let i = lastFreezedOutput ? lastFreezedOutput.index + 1 : 0;\n  for (; i < txSkeleton.get(\"outputs\").size && _amount.gt(0); ++i) {\n    const output = txSkeleton.get(\"outputs\").get(i)!;\n    if (\n      new ScriptValue(output.cellOutput.lock, { validate: false }).equals(\n        new ScriptValue(fromScript, { validate: false })\n      )\n    ) {\n      const cellCapacity = BI.from(output.cellOutput.capacity);\n      let deductCapacity;\n      if (_amount.gte(cellCapacity)) {\n        deductCapacity = cellCapacity;\n      } else {\n        deductCapacity = cellCapacity.sub(\n          minimalCellCapacityCompatible(output)\n        );\n        if (deductCapacity.gt(_amount)) {\n          deductCapacity = _amount;\n        }\n      }\n      _amount = _amount.sub(deductCapacity);\n      output.cellOutput.capacity =\n        \"0x\" + cellCapacity.sub(deductCapacity).toString(16);\n    }\n  }\n  // remove all output cells with capacity equal to 0\n  txSkeleton = txSkeleton.update(\"outputs\", (outputs) => {\n    return outputs.filter(\n      (output) => !BI.from(output.cellOutput.capacity).eq(0)\n    );\n  });\n  /*\n   * Collect and add new input cells so as to prepare remaining capacities.\n   */\n  if (_amount.gt(0)) {\n    const cellProvider = txSkeleton.get(\"cellProvider\");\n    if (!cellProvider) {\n      throw new Error(\"cell provider is missing!\");\n    }\n    // TODO: ignore locktime now.\n    const cellCollector = cellProvider.collector({\n      lock: fromScript,\n    });\n    const changeCell: Cell = {\n      cellOutput: {\n        capacity: \"0x0\",\n        lock: fromScript,\n        type: undefined,\n      },\n      data: \"0x\",\n      outPoint: undefined,\n      blockHash: undefined,\n    };\n    let changeCapacity = BI.from(0);\n    let previousInputs = Set<string>();\n    for (const input of txSkeleton.get(\"inputs\")) {\n      previousInputs = previousInputs.add(\n        `${input.outPoint!.txHash}_${input.outPoint!.index}`\n      );\n    }\n    for await (const inputCell of cellCollector.collect()) {\n      // skip inputs already exists in txSkeleton.inputs\n      if (\n        previousInputs.has(\n          `${inputCell.outPoint!.txHash}_${inputCell.outPoint!.index}`\n        )\n      ) {\n        continue;\n      }\n      txSkeleton = txSkeleton.update(\"inputs\", (inputs) =>\n        inputs.push(inputCell)\n      );\n      txSkeleton = txSkeleton.update(\"witnesses\", (witnesses) =>\n        witnesses.push(\"0x\")\n      );\n      const inputCapacity = BI.from(inputCell.cellOutput.capacity);\n      let deductCapacity = inputCapacity;\n      if (deductCapacity.gt(_amount)) {\n        deductCapacity = _amount;\n      }\n      _amount = _amount.sub(deductCapacity);\n      changeCapacity = changeCapacity.add(inputCapacity.sub(deductCapacity));\n      if (\n        _amount.eq(0) &&\n        (changeCapacity.eq(0) ||\n          changeCapacity.gt(minimalCellCapacityCompatible(changeCell)))\n      ) {\n        break;\n      }\n    }\n    if (changeCapacity.gt(0)) {\n      changeCell.cellOutput.capacity = \"0x\" + changeCapacity.toString(16);\n      txSkeleton = txSkeleton.update(\"outputs\", (outputs) =>\n        outputs.push(changeCell)\n      );\n    }\n  }\n  if (_amount.gt(0) && assertAmountEnough) {\n    throw new Error(\"Not enough capacity in from address!\");\n  }\n\n  const firstIndex = txSkeleton\n    .get(\"inputs\")\n    .findIndex((input) =>\n      new ScriptValue(input.cellOutput.lock, { validate: false }).equals(\n        new ScriptValue(fromScript!, { validate: false })\n      )\n    );\n  if (firstIndex !== -1) {\n    while (BI.from(firstIndex).gte(txSkeleton.get(\"witnesses\").size)) {\n      txSkeleton = txSkeleton.update(\"witnesses\", (witnesses) =>\n        witnesses.push(\"0x\")\n      );\n    }\n\n    // if using MultisigScript, check witnesses\n    if (noMultisigBefore || typeof fromInfo !== \"string\") {\n      let witness = txSkeleton.get(\"witnesses\").get(firstIndex)!;\n      const newWitnessArgs: WitnessArgs = {\n        lock:\n          \"0x\" +\n          multisigScript!.slice(2) +\n          SECP_SIGNATURE_PLACEHOLDER.slice(2).repeat(\n            (fromInfo as MultisigScript).M\n          ),\n      };\n      if (witness !== \"0x\") {\n        const witnessArgs = blockchain.WitnessArgs.unpack(\n          bytes.bytify(witness)\n        );\n        const lock = witnessArgs.lock;\n        if (\n          !!lock &&\n          !!newWitnessArgs.lock &&\n          !bytes.equal(lock, newWitnessArgs.lock)\n        ) {\n          throw new Error(\n            \"Lock field in first witness is set aside for signature!\"\n          );\n        }\n        const inputType = witnessArgs.inputType;\n        if (inputType) {\n          newWitnessArgs.inputType = inputType;\n        }\n        const outputType = witnessArgs.outputType;\n        if (outputType) {\n          newWitnessArgs.outputType = outputType;\n        }\n      }\n      witness = bytes.hexify(blockchain.WitnessArgs.pack(newWitnessArgs));\n      txSkeleton = txSkeleton.update(\"witnesses\", (witnesses) =>\n        witnesses.set(firstIndex, witness)\n      );\n    }\n  }\n  if (!assertAmountEnough) {\n    return [txSkeleton, BI.from(_amount)];\n  }\n  return txSkeleton;\n}\n\n/**\n * pay fee by multisig script cells\n *\n * @param txSkeleton\n * @param fromInfo\n * @param amount fee in shannon\n * @param options\n */\nexport async function payFee(\n  txSkeleton: TransactionSkeletonType,\n  fromInfo: FromInfo,\n  amount: BIish,\n  { config = undefined }: Options = {}\n): Promise<TransactionSkeletonType> {\n  config = config || getConfig();\n  return transferCompatible(txSkeleton, fromInfo, undefined, amount, {\n    config,\n    requireToAddress: false,\n  });\n}\n\n/**\n * Inject capacity from `fromInfo` to target output.\n *\n * @param txSkeleton\n * @param outputIndex\n * @param fromInfo\n * @param options\n */\nexport async function injectCapacity(\n  txSkeleton: TransactionSkeletonType,\n  outputIndex: number,\n  fromInfo: FromInfo,\n  { config = undefined }: Options = {}\n): Promise<TransactionSkeletonType> {\n  config = config || getConfig();\n  if (outputIndex >= txSkeleton.get(\"outputs\").size) {\n    throw new Error(\"Invalid output index!\");\n  }\n  const capacity = BI.from(\n    txSkeleton.get(\"outputs\").get(outputIndex)!.cellOutput.capacity\n  );\n  return transferCompatible(txSkeleton, fromInfo, undefined, capacity, {\n    config,\n    requireToAddress: false,\n  });\n}\n\n/**\n * prepare for txSkeleton signingEntries, will update txSkeleton.get(\"signingEntries\")\n *\n * @param txSkeleton\n * @param options\n */\nexport function prepareSigningEntries(\n  txSkeleton: TransactionSkeletonType,\n  { config = undefined }: Options = {}\n): TransactionSkeletonType {\n  config = config || getConfig();\n\n  return _prepareSigningEntries(\n    txSkeleton,\n    config,\n    \"SECP256K1_BLAKE160_MULTISIG\"\n  );\n}\n\nexport default {\n  transfer,\n  transferCompatible,\n  payFee,\n  prepareSigningEntries,\n  serializeMultisigScript,\n  multisigArgs,\n  injectCapacity,\n  setupInputCell,\n  CellCollector,\n};\n"],"mappings":"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"}