{"version":3,"file":"locktime_pool.js","names":["_helpers","require","_codec","_from_info","_secp256k1_blake","_interopRequireDefault","_dao","_base","_helper","_immutable","_configManager","_","_since","_bi","_rpc","obj","__esModule","default","ScriptValue","values","parseEpoch","maximumAbsoluteEpochSince","generateAbsoluteEpochSince","validateSince","sinceUtils","CellCollector","constructor","fromInfo","cellProvider","config","undefined","queryOptions","tipHeader","NodeRPC","RPC","Error","getConfig","result","parseFromInfo","fromScript","multisigScript","tipSinceValidationInfo","blockNumber","number","epoch","median_timestamp","rpc","uri","lock","cellCollectors","List","isSecp256k1Blake160MultisigScript","codeHash","hashType","args","slice","push","collector","argsLen","type","data","generateDaoScript","isSecp256k1Blake160Script","collect","cellCollector","inputCell","cellOutput","since","maximumCapacity","depositBlockHash","withdrawBlockHash","sinceValidationInfo","length","header","getHeader","blockHash","_parseMultisigArgsSinceCompatible","toString","isDaoScript","transactionWithStatus","getTransaction","outPoint","txHash","txStatus","transaction","depositOutPoint","inputs","index","previousOutput","depositBlockHeader","withdrawBlockHeader","daoSince","calculateDaoEarliestSinceCompatible","calculateMaximumWithdrawCompatible","dao","withdrawEpochValue","fourEpochsLater","multisigSince","parseSinceCompatible","relative","capacity","BI","from","exports","transfer","txSkeleton","fromInfos","toAddress","amount","requireToAddress","assertAmountEnough","LocktimeCellCollector","transferCompatible","_txSkeleton","_amount","Array","BigInt","entries","value","_transferCompatible","eq","changeAddress","toScript","parseAddress","update","outputs","lastFreezedOutput","get","filter","field","maxBy","i","size","gt","output","validate","equals","cellCapacity","deductCapacity","gte","sub","minimalCellCapacityCompatible","clonedOutput","JSON","parse","stringify","changeLockScript","changeCell","changeCapacity","previousInputs","Set","input","add","cell","has","lockArgs","witness","template","SCRIPTS","DAO","addCellDep","depType","DEP_TYPE","TX_HASH","INDEX","headerDeps","depositHeaderDepIndex","witnessArgs","inputType","bytes","hexify","Uint64","pack","blockchain","WitnessArgs","collectInput","Object","assign","defaultWitness","inputCapacity","fixedEntries","injectCapacityWithoutChangeCompatible","minimalChangeCapacity","enableDeductCapacity","_minimalChangeCapacity","getInputKey","injectCapacityWithoutChange","toBigInt","payFee","prepareSigningEntries","_prepareSigningEntries","injectCapacity","outputIndex","setupInputCell","remove","inputLock","secp256k1Blake160","secp256k1Blake160Multisig","Uint64LE","unpack","_default"],"sources":["../src/locktime_pool.ts"],"sourcesContent":["import {\n  parseAddress,\n  Options,\n  TransactionSkeletonType,\n  minimalCellCapacityCompatible,\n} from \"@ckb-lumos/helpers\";\nimport { bytes, number } from \"@ckb-lumos/codec\";\nimport { FromInfo, parseFromInfo } from \"./from_info\";\nimport secp256k1Blake160 from \"./secp256k1_blake160\";\nimport {\n  calculateMaximumWithdrawCompatible,\n  calculateDaoEarliestSinceCompatible,\n} from \"./dao\";\nimport {\n  values,\n  since as sinceUtils,\n  CellProvider,\n  Script,\n  PackedSince,\n  Cell,\n  Hash,\n  HexString,\n  Address,\n  Header,\n  QueryOptions,\n  CellCollector as CellCollectorType,\n  SinceValidationInfo,\n  blockchain,\n} from \"@ckb-lumos/base\";\nconst { ScriptValue } = values;\nimport {\n  generateDaoScript,\n  isSecp256k1Blake160MultisigScript,\n  isSecp256k1Blake160Script,\n  isDaoScript,\n  prepareSigningEntries as _prepareSigningEntries,\n  addCellDep,\n} from \"./helper\";\nconst {\n  parseEpoch,\n  maximumAbsoluteEpochSince,\n  generateAbsoluteEpochSince,\n  validateSince,\n} = sinceUtils;\nimport { List, Set } from \"immutable\";\nimport { getConfig, Config } from \"@ckb-lumos/config-manager\";\nimport { secp256k1Blake160Multisig } from \".\";\nimport { parseSinceCompatible } from \"@ckb-lumos/base/lib/since\";\nimport { BI, BIish } from \"@ckb-lumos/bi\";\nimport { CellCollectorConstructor } from \"./type\";\nimport { RPC } from \"@ckb-lumos/rpc\";\n\nexport interface LocktimeCell extends Cell {\n  since: PackedSince;\n  depositBlockHash?: Hash;\n  withdrawBlockHash?: Hash;\n  sinceValidationInfo?: SinceValidationInfo;\n}\nexport const CellCollector: CellCollectorConstructor = class CellCollector\n  implements CellCollectorType\n{\n  private cellCollectors: List<CellCollectorType>;\n  private config: Config;\n  private rpc: RPC;\n  private tipHeader?: Header;\n  private tipSinceValidationInfo?: SinceValidationInfo;\n  public readonly fromScript: Script;\n  public readonly multisigScript?: HexString;\n  constructor(\n    fromInfo: FromInfo,\n    cellProvider: CellProvider,\n    {\n      config = undefined,\n      queryOptions = {},\n      tipHeader = undefined,\n      NodeRPC = RPC,\n    }: Options & {\n      queryOptions?: QueryOptions;\n      tipHeader?: Header;\n      NodeRPC?: typeof RPC;\n    } = {}\n  ) {\n    if (!cellProvider) {\n      throw new Error(`Cell provider is missing!`);\n    }\n    config = config || getConfig();\n    const result = parseFromInfo(fromInfo, { config });\n    const fromScript = result.fromScript;\n    this.multisigScript = result.multisigScript;\n    this.fromScript = fromScript;\n\n    this.config = config;\n    this.tipHeader = tipHeader;\n\n    if (tipHeader) {\n      // TODO: `median_timestamp` is not provided now!\n      this.tipSinceValidationInfo = {\n        blockNumber: tipHeader.number,\n        epoch: tipHeader.epoch,\n        median_timestamp: \"\",\n      };\n    }\n\n    this.rpc = new NodeRPC(cellProvider.uri!);\n\n    queryOptions = {\n      ...queryOptions,\n      lock: this.fromScript,\n    };\n\n    let cellCollectors = List<CellCollectorType>([]);\n    if (isSecp256k1Blake160MultisigScript(fromScript, config)) {\n      const lock: Script = {\n        codeHash: fromScript.codeHash,\n        hashType: fromScript.hashType,\n        args: fromScript.args.slice(0, 42),\n      };\n      // multisig with locktime, not dao\n      cellCollectors = cellCollectors.push(\n        cellProvider.collector({\n          lock,\n          argsLen: queryOptions.argsLen || 28,\n          type: queryOptions.type || \"empty\",\n          data: queryOptions.data || \"0x\",\n        })\n      );\n      // multisig without locktime, dao\n      if (\n        !queryOptions.type &&\n        (!queryOptions.data || queryOptions.data === \"any\")\n      ) {\n        cellCollectors = cellCollectors.push(\n          cellProvider.collector({\n            lock,\n            type: generateDaoScript(config),\n            data: \"any\",\n          })\n        );\n        // multisig with locktime, dao\n        cellCollectors = cellCollectors.push(\n          cellProvider.collector({\n            lock,\n            argsLen: 28,\n            type: generateDaoScript(config),\n            data: \"any\",\n          })\n        );\n      }\n    } else if (isSecp256k1Blake160Script(fromScript, config)) {\n      // secp256k1_blake160, dao\n      if (\n        !queryOptions.type &&\n        (!queryOptions.data || queryOptions.data === \"any\")\n      ) {\n        cellCollectors = cellCollectors.push(\n          cellProvider.collector({\n            lock: fromScript,\n            type: generateDaoScript(config),\n            data: \"any\",\n          })\n        );\n      }\n    }\n\n    this.cellCollectors = cellCollectors;\n  }\n\n  async *collect(): AsyncGenerator<LocktimeCell> {\n    for (const cellCollector of this.cellCollectors) {\n      for await (const inputCell of cellCollector.collect()) {\n        const lock = inputCell.cellOutput.lock;\n\n        let since: PackedSince | undefined;\n        let maximumCapacity: BI | undefined;\n        let depositBlockHash: Hash | undefined;\n        let withdrawBlockHash: Hash | undefined;\n        let sinceValidationInfo: SinceValidationInfo | undefined;\n\n        // multisig\n        if (lock.args.length === 58) {\n          const header = (await this.rpc.getHeader(inputCell.blockHash!))!;\n          since =\n            \"0x\" + _parseMultisigArgsSinceCompatible(lock.args).toString(16);\n          // TODO: `median_timestamp` not provided now!\n          sinceValidationInfo = {\n            epoch: header.epoch,\n            blockNumber: header.number,\n            median_timestamp: \"\",\n          };\n        }\n\n        // dao\n        if (isDaoScript(inputCell.cellOutput.type, this.config)) {\n          if (inputCell.data === \"0x0000000000000000\") {\n            continue;\n          }\n          const transactionWithStatus = (await this.rpc.getTransaction(\n            inputCell.outPoint!.txHash\n          ))!;\n          withdrawBlockHash = transactionWithStatus.txStatus.blockHash;\n          const transaction = transactionWithStatus.transaction;\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n          const depositOutPoint =\n            transaction.inputs[+inputCell.outPoint!.index].previousOutput;\n          depositBlockHash = (await this.rpc.getTransaction(\n            depositOutPoint!.txHash\n          ))!.txStatus.blockHash!;\n          const depositBlockHeader = await this.rpc.getHeader(depositBlockHash);\n          const withdrawBlockHeader = await this.rpc.getHeader(\n            withdrawBlockHash!\n          );\n          let daoSince: PackedSince =\n            \"0x\" +\n            calculateDaoEarliestSinceCompatible(\n              depositBlockHeader!.epoch,\n              withdrawBlockHeader!.epoch\n            ).toString(16);\n          maximumCapacity = calculateMaximumWithdrawCompatible(\n            inputCell,\n            depositBlockHeader!.dao,\n            withdrawBlockHeader!.dao\n          );\n          const withdrawEpochValue = parseEpoch(withdrawBlockHeader!.epoch);\n          const fourEpochsLater = {\n            number: withdrawEpochValue.number + 4,\n            length: withdrawEpochValue.length,\n            index: withdrawEpochValue.index,\n          };\n          daoSince = maximumAbsoluteEpochSince(\n            daoSince,\n            generateAbsoluteEpochSince(fourEpochsLater)\n          );\n\n          // if multisig with locktime\n          if (since) {\n            const multisigSince = parseSinceCompatible(since);\n            if (\n              !(\n                multisigSince.relative === false &&\n                multisigSince.type === \"epochNumber\"\n              )\n            ) {\n              // throw new Error(\n              //   \"Multisig since not an absolute-epoch-number since format!\"\n              // );\n              // skip multisig with locktime in non-absolute-epoch-number format, can't unlock it\n              continue;\n            }\n\n            try {\n              since = maximumAbsoluteEpochSince(daoSince, since);\n            } catch {\n              since = daoSince;\n            }\n          } else {\n            since = daoSince;\n          }\n        }\n\n        if (\n          parseSinceCompatible(since!).type === \"blockTimestamp\" ||\n          (this.tipHeader &&\n            !validateSince(\n              since!,\n              this.tipSinceValidationInfo!,\n              // TODO: modify the parameter type of `validateSince`\n              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n              sinceValidationInfo!\n            ))\n        ) {\n          continue;\n        }\n\n        const result = {\n          ...inputCell,\n          since: since!,\n          depositBlockHash: depositBlockHash,\n          withdrawBlockHash: withdrawBlockHash,\n          sinceValidationInfo,\n        };\n        result.cellOutput.capacity =\n          \"0x\" +\n          (maximumCapacity || BI.from(inputCell.cellOutput.capacity)).toString(\n            16\n          );\n\n        yield result;\n      }\n    }\n  }\n};\n\nexport async function transfer(\n  txSkeleton: TransactionSkeletonType,\n  fromInfos: FromInfo[],\n  toAddress: Address | undefined,\n  amount: bigint,\n  tipHeader: Header,\n  {\n    config,\n    requireToAddress,\n    assertAmountEnough,\n    LocktimeCellCollector,\n  }: {\n    config?: Config;\n    requireToAddress?: boolean;\n    assertAmountEnough?: true;\n    LocktimeCellCollector?: CellCollectorConstructor;\n  }\n): Promise<TransactionSkeletonType>;\n\nexport async function transfer(\n  txSkeleton: TransactionSkeletonType,\n  fromInfos: FromInfo[],\n  toAddress: Address | undefined,\n  amount: bigint,\n  tipHeader: Header,\n  {\n    config,\n    requireToAddress,\n    assertAmountEnough,\n    LocktimeCellCollector,\n  }: {\n    config?: Config;\n    requireToAddress?: boolean;\n    assertAmountEnough: false;\n    LocktimeCellCollector?: CellCollectorConstructor;\n  }\n): Promise<[TransactionSkeletonType, bigint]>;\n\nexport async function transfer(\n  txSkeleton: TransactionSkeletonType,\n  fromInfos: FromInfo[],\n  toAddress: Address | undefined,\n  amount: bigint,\n  tipHeader: Header,\n  {\n    config = undefined,\n    requireToAddress = true,\n    assertAmountEnough = true,\n    LocktimeCellCollector = CellCollector,\n  }: {\n    config?: Config;\n    requireToAddress?: boolean;\n    assertAmountEnough?: boolean;\n    LocktimeCellCollector?: CellCollectorConstructor;\n  } = {}\n): Promise<TransactionSkeletonType | [TransactionSkeletonType, bigint]> {\n  const result = await transferCompatible(\n    txSkeleton,\n    fromInfos,\n    toAddress,\n    amount,\n    tipHeader,\n    {\n      config,\n      requireToAddress,\n      assertAmountEnough: assertAmountEnough as true | undefined,\n      LocktimeCellCollector,\n    }\n  );\n  let _txSkeleton: TransactionSkeletonType;\n  let _amount: bigint;\n  if (result instanceof Array) {\n    _txSkeleton = result[0];\n    _amount = BigInt(result[1].toString());\n    return [_txSkeleton, _amount];\n  } else {\n    _txSkeleton = result;\n    return _txSkeleton;\n  }\n}\n\nexport async function transferCompatible(\n  txSkeleton: TransactionSkeletonType,\n  fromInfos: FromInfo[],\n  toAddress: Address | undefined,\n  amount: BIish,\n  tipHeader: Header,\n  {\n    config,\n    requireToAddress,\n    assertAmountEnough,\n    LocktimeCellCollector,\n  }: {\n    config?: Config;\n    requireToAddress?: boolean;\n    assertAmountEnough?: true;\n    LocktimeCellCollector?: CellCollectorConstructor;\n  }\n): Promise<TransactionSkeletonType>;\n\nexport async function transferCompatible(\n  txSkeleton: TransactionSkeletonType,\n  fromInfos: FromInfo[],\n  toAddress: Address | undefined,\n  amount: BIish,\n  tipHeader: Header,\n  {\n    config,\n    requireToAddress,\n    assertAmountEnough,\n    LocktimeCellCollector,\n  }: {\n    config?: Config;\n    requireToAddress?: boolean;\n    assertAmountEnough: false;\n    LocktimeCellCollector?: CellCollectorConstructor;\n  }\n): Promise<[TransactionSkeletonType, BI]>;\nexport async function transferCompatible(\n  txSkeleton: TransactionSkeletonType,\n  fromInfos: FromInfo[],\n  toAddress: Address | undefined,\n  amount: BIish,\n  tipHeader: Header,\n  {\n    config = undefined,\n    requireToAddress = true,\n    assertAmountEnough = true,\n    LocktimeCellCollector = CellCollector,\n  }: {\n    config?: Config;\n    requireToAddress?: boolean;\n    assertAmountEnough?: boolean;\n    LocktimeCellCollector?: CellCollectorConstructor;\n  } = {}\n): Promise<TransactionSkeletonType | [TransactionSkeletonType, BI]> {\n  let _amount = BI.from(amount);\n  for (const [index, fromInfo] of fromInfos.entries()) {\n    const value = (await _transferCompatible(\n      txSkeleton,\n      fromInfo,\n      index === 0 ? toAddress : undefined,\n      _amount,\n      tipHeader,\n      {\n        config,\n        requireToAddress: index === 0 ? requireToAddress : false,\n        assertAmountEnough: false,\n        LocktimeCellCollector,\n      }\n    )) as [TransactionSkeletonType, BI];\n    // [txSkeleton, amount] = value\n    txSkeleton = value[0];\n    _amount = value[1];\n\n    if (_amount.eq(0)) {\n      if (assertAmountEnough) {\n        return txSkeleton;\n      }\n      return [txSkeleton, BI.from(_amount)];\n    }\n  }\n\n  if (assertAmountEnough) {\n    throw new Error(\"Not enough capacity in from addresses!\");\n  }\n  return [txSkeleton, BI.from(_amount)];\n}\n\nasync function _transferCompatible(\n  txSkeleton: TransactionSkeletonType,\n  fromInfo: FromInfo,\n  toAddress: Address | undefined,\n  amount: BIish,\n  tipHeader: Header,\n  {\n    config = undefined,\n    requireToAddress = true,\n    assertAmountEnough = true,\n    LocktimeCellCollector = CellCollector,\n    changeAddress = undefined,\n  }: {\n    config?: Config;\n    requireToAddress?: boolean;\n    assertAmountEnough?: boolean;\n    LocktimeCellCollector: CellCollectorConstructor;\n    changeAddress?: Address;\n  }\n): Promise<TransactionSkeletonType | [TransactionSkeletonType, BI]> {\n  config = config || getConfig();\n  // fromScript can be secp256k1_blake160 / secp256k1_blake160_multisig\n  const { fromScript } = parseFromInfo(fromInfo, { config });\n\n  // validate fromScript\n  if (\n    !isSecp256k1Blake160MultisigScript(fromScript, config) &&\n    !isSecp256k1Blake160Script(fromScript, config)\n  ) {\n    throw new Error(\"fromInfo not supported!\");\n  }\n\n  if (requireToAddress && !toAddress) {\n    throw new Error(\"You must provide a to address!\");\n  }\n\n  let _amount = BI.from(amount || 0);\n  if (toAddress) {\n    const toScript = parseAddress(toAddress, { config });\n\n    txSkeleton = txSkeleton.update(\"outputs\", (outputs) => {\n      return outputs.push({\n        cellOutput: {\n          capacity: \"0x\" + _amount.toString(16),\n          lock: toScript,\n          type: undefined,\n        },\n        data: \"0x\",\n        outPoint: undefined,\n        blockHash: undefined,\n      });\n    });\n  }\n\n  const lastFreezedOutput = txSkeleton\n    .get(\"fixedEntries\")\n    .filter(({ field }) => field === \"outputs\")\n    .maxBy(({ index }) => index);\n  let i = lastFreezedOutput ? lastFreezedOutput.index + 1 : 0;\n  for (; i < txSkeleton.get(\"outputs\").size && _amount.gt(0); ++i) {\n    const output = txSkeleton.get(\"outputs\").get(i)!;\n    if (\n      new ScriptValue(output.cellOutput.lock, { validate: false }).equals(\n        new ScriptValue(fromScript, { validate: false })\n      )\n    ) {\n      const cellCapacity = BI.from(output.cellOutput.capacity);\n      let deductCapacity;\n      if (_amount.gte(cellCapacity)) {\n        deductCapacity = cellCapacity;\n      } else {\n        deductCapacity = cellCapacity.sub(\n          minimalCellCapacityCompatible(output)\n        );\n        if (deductCapacity.gt(_amount)) {\n          deductCapacity = _amount;\n        }\n      }\n      _amount = _amount.sub(deductCapacity);\n\n      const clonedOutput = JSON.parse(JSON.stringify(output));\n      clonedOutput.cellOutput.capacity =\n        \"0x\" + cellCapacity.sub(deductCapacity).toString(16);\n      txSkeleton = txSkeleton.update(\"outputs\", (outputs) => {\n        return outputs.update(i, () => clonedOutput);\n      });\n    }\n  }\n  // remove all output cells with capacity equal to 0\n  txSkeleton = txSkeleton.update(\"outputs\", (outputs) => {\n    return outputs.filter(\n      (output) => !BI.from(output.cellOutput.capacity).eq(0)\n    );\n  });\n  /*\n   * Collect and add new input cells so as to prepare remaining capacities.\n   */\n  if (_amount.gt(0)) {\n    const cellProvider = txSkeleton.get(\"cellProvider\");\n    if (!cellProvider) {\n      throw new Error(\"cell provider is missing!\");\n    }\n\n    const changeLockScript: Script = changeAddress\n      ? parseAddress(changeAddress, { config })\n      : fromScript;\n    const changeCell: Cell = {\n      cellOutput: {\n        capacity: \"0x0\",\n        lock: changeLockScript,\n        type: undefined,\n      },\n      data: \"0x\",\n      outPoint: undefined,\n      blockHash: undefined,\n    };\n    let changeCapacity = BI.from(0);\n\n    let previousInputs = Set<string>();\n    for (const input of txSkeleton.get(\"inputs\")) {\n      previousInputs = previousInputs.add(\n        `${input.outPoint!.txHash}_${input.outPoint!.index}`\n      );\n    }\n    const cellCollector = new LocktimeCellCollector(fromInfo, cellProvider, {\n      config,\n      tipHeader,\n    });\n    for await (const cell of cellCollector.collect()) {\n      const inputCell = cell as LocktimeCell;\n      // skip inputs already exists in txSkeleton.inputs\n      if (\n        previousInputs.has(\n          `${inputCell.outPoint!.txHash}_${inputCell.outPoint!.index}`\n        )\n      ) {\n        continue;\n      }\n\n      let multisigSince: BI | undefined;\n      if (isSecp256k1Blake160MultisigScript(fromScript, config)) {\n        const lockArgs = inputCell.cellOutput.lock.args;\n        multisigSince =\n          lockArgs.length === 58\n            ? BI.from(_parseMultisigArgsSinceCompatible(lockArgs))\n            : undefined;\n      }\n      let witness: HexString = \"0x\";\n      if (isDaoScript(inputCell.cellOutput.type, config)) {\n        const template = config.SCRIPTS.DAO!;\n        txSkeleton = addCellDep(txSkeleton, {\n          depType: template.DEP_TYPE,\n          outPoint: {\n            txHash: template.TX_HASH,\n            index: template.INDEX,\n          },\n        });\n\n        txSkeleton = txSkeleton.update(\"headerDeps\", (headerDeps) => {\n          return headerDeps.push(\n            inputCell.depositBlockHash!,\n            inputCell.withdrawBlockHash!\n          );\n        });\n\n        const depositHeaderDepIndex = txSkeleton.get(\"headerDeps\").size - 2;\n\n        const witnessArgs = {\n          inputType: bytes.hexify(number.Uint64.pack(depositHeaderDepIndex)),\n        };\n        witness = bytes.hexify(blockchain.WitnessArgs.pack(witnessArgs));\n      }\n\n      txSkeleton = await collectInput(\n        txSkeleton,\n        inputCell,\n        isSecp256k1Blake160MultisigScript(fromScript, config)\n          ? Object.assign({}, fromInfo, { since: multisigSince })\n          : fromInfo,\n        { config, defaultWitness: witness, since: inputCell.since }\n      );\n\n      const inputCapacity = BI.from(inputCell.cellOutput.capacity);\n      let deductCapacity = inputCapacity;\n      if (deductCapacity.gt(_amount)) {\n        deductCapacity = _amount;\n      }\n      _amount = _amount.sub(deductCapacity);\n      changeCapacity = changeCapacity.add(inputCapacity).sub(deductCapacity);\n      if (isDaoScript(inputCell.cellOutput.type, config)) {\n        // fix inputs / outputs / witnesses\n        txSkeleton = txSkeleton.update(\"fixedEntries\", (fixedEntries) => {\n          return fixedEntries.push(\n            {\n              field: \"inputs\",\n              index: txSkeleton.get(\"inputs\").size - 1,\n            },\n            {\n              field: \"witnesses\",\n              index: txSkeleton.get(\"witnesses\").size - 1,\n            },\n            {\n              field: \"headerDeps\",\n              index: txSkeleton.get(\"headerDeps\").size - 2,\n            }\n          );\n        });\n      }\n      if (\n        _amount.eq(0) &&\n        (changeCapacity.eq(0) ||\n          changeCapacity.gt(minimalCellCapacityCompatible(changeCell)))\n      ) {\n        break;\n      }\n    }\n    if (changeCapacity.gt(0)) {\n      changeCell.cellOutput.capacity = \"0x\" + changeCapacity.toString(16);\n      txSkeleton = txSkeleton.update(\"outputs\", (outputs) =>\n        outputs.push(changeCell)\n      );\n    }\n  }\n\n  if (!assertAmountEnough) {\n    return [txSkeleton, _amount];\n  }\n\n  if (_amount.gt(0)) {\n    throw new Error(\"Not enough capacity in from address!\");\n  }\n\n  return txSkeleton;\n}\n\nasync function injectCapacityWithoutChangeCompatible(\n  txSkeleton: TransactionSkeletonType,\n  fromInfos: FromInfo[],\n  amount: BIish,\n  tipHeader: Header,\n  minimalChangeCapacity: BIish,\n  {\n    config = undefined,\n    LocktimeCellCollector = CellCollector,\n    enableDeductCapacity = true,\n  }: {\n    config?: Config;\n    LocktimeCellCollector?: CellCollectorConstructor;\n    enableDeductCapacity?: boolean;\n  }\n): Promise<{\n  txSkeleton: TransactionSkeletonType;\n  capacity: BI;\n  changeCapacity: BI;\n}> {\n  config = config || getConfig();\n  // fromScript can be secp256k1_blake160 / secp256k1_blake160_multisig\n\n  let _amount = BI.from(amount);\n  const _minimalChangeCapacity = BI.from(minimalChangeCapacity);\n  if (enableDeductCapacity) {\n    for (const fromInfo of fromInfos) {\n      const fromScript: Script = parseFromInfo(fromInfo, { config }).fromScript;\n      // validate fromScript\n      if (\n        !isSecp256k1Blake160MultisigScript(fromScript, config) &&\n        !isSecp256k1Blake160Script(fromScript, config)\n      ) {\n        // Skip if not support.\n        continue;\n      }\n      const lastFreezedOutput = txSkeleton\n        .get(\"fixedEntries\")\n        .filter(({ field }) => field === \"outputs\")\n        .maxBy(({ index }) => index);\n      let i = lastFreezedOutput ? lastFreezedOutput.index + 1 : 0;\n      for (; i < txSkeleton.get(\"outputs\").size && _amount.gt(0); ++i) {\n        const output = txSkeleton.get(\"outputs\").get(i)!;\n        if (\n          new ScriptValue(output.cellOutput.lock, { validate: false }).equals(\n            new ScriptValue(fromScript, { validate: false })\n          )\n        ) {\n          const clonedOutput: Cell = JSON.parse(JSON.stringify(output));\n          const cellCapacity = BI.from(clonedOutput.cellOutput.capacity);\n          let deductCapacity;\n          if (_amount.gte(cellCapacity)) {\n            deductCapacity = cellCapacity;\n          } else {\n            deductCapacity = cellCapacity.sub(\n              minimalCellCapacityCompatible(clonedOutput)\n            );\n            if (deductCapacity.gt(_amount)) {\n              deductCapacity = _amount;\n            }\n          }\n          _amount = _amount.sub(deductCapacity);\n          clonedOutput.cellOutput.capacity =\n            \"0x\" + cellCapacity.sub(deductCapacity).toString(16);\n\n          txSkeleton = txSkeleton.update(\"outputs\", (outputs) => {\n            return outputs.update(i, () => clonedOutput);\n          });\n        }\n      }\n      // remove all output cells with capacity equal to 0\n      txSkeleton = txSkeleton.update(\"outputs\", (outputs) => {\n        return outputs.filter(\n          (output) => !BI.from(output.cellOutput.capacity).eq(0)\n        );\n      });\n    }\n  }\n\n  /*\n   * Collect and add new input cells so as to prepare remaining capacities.\n   */\n  let changeCapacity = BI.from(0);\n  if (_amount.gt(0)) {\n    const cellProvider = txSkeleton.get(\"cellProvider\");\n    if (!cellProvider) {\n      throw new Error(\"cell provider is missing!\");\n    }\n\n    const getInputKey = (input: Cell) =>\n      `${input.outPoint!.txHash}_${input.outPoint!.index}`;\n    let previousInputs = Set<string>();\n    for (const input of txSkeleton.get(\"inputs\")) {\n      previousInputs = previousInputs.add(getInputKey(input));\n    }\n\n    for (const fromInfo of fromInfos) {\n      const fromScript: Script = parseFromInfo(fromInfo, { config }).fromScript;\n      const cellCollector = new LocktimeCellCollector(fromInfo, cellProvider, {\n        config,\n        tipHeader,\n      });\n      for await (const cell of cellCollector.collect()) {\n        const inputCell = cell as LocktimeCell;\n        // skip inputs already exists in txSkeleton.inputs\n        if (previousInputs.has(getInputKey(inputCell))) {\n          continue;\n        }\n\n        let witness: HexString = \"0x\";\n        if (isDaoScript(inputCell.cellOutput.type, config)) {\n          const template = config.SCRIPTS.DAO!;\n          txSkeleton = addCellDep(txSkeleton, {\n            depType: template.DEP_TYPE,\n            outPoint: {\n              txHash: template.TX_HASH,\n              index: template.INDEX,\n            },\n          });\n\n          txSkeleton = txSkeleton.update(\"headerDeps\", (headerDeps) => {\n            return headerDeps.push(\n              inputCell.depositBlockHash!,\n              inputCell.withdrawBlockHash!\n            );\n          });\n\n          const depositHeaderDepIndex = txSkeleton.get(\"headerDeps\").size - 2;\n          const witnessArgs = {\n            inputType: bytes.hexify(number.Uint64.pack(depositHeaderDepIndex)),\n          };\n          witness = bytes.hexify(blockchain.WitnessArgs.pack(witnessArgs));\n        }\n        let multisigSince: BI | undefined;\n        if (isSecp256k1Blake160MultisigScript(fromScript, config)) {\n          // multisig\n          const lockArgs = inputCell.cellOutput.lock.args;\n          multisigSince =\n            lockArgs.length === 58\n              ? BI.from(_parseMultisigArgsSinceCompatible(lockArgs))\n              : undefined;\n        }\n        txSkeleton = await collectInput(\n          txSkeleton,\n          inputCell,\n          Object.assign({}, fromInfo, { since: multisigSince }),\n          {\n            config,\n            defaultWitness: witness,\n            since: inputCell.since,\n          }\n        );\n\n        const inputCapacity = BI.from(inputCell.cellOutput.capacity);\n        let deductCapacity = inputCapacity;\n        if (deductCapacity.gt(_amount)) {\n          deductCapacity = _amount;\n        }\n        _amount = _amount.sub(deductCapacity);\n        changeCapacity = changeCapacity.add(inputCapacity).sub(deductCapacity);\n\n        if (isDaoScript(inputCell.cellOutput.type, config)) {\n          // fix inputs / outputs / witnesses\n          txSkeleton = txSkeleton.update(\"fixedEntries\", (fixedEntries) => {\n            return fixedEntries.push(\n              {\n                field: \"inputs\",\n                index: txSkeleton.get(\"inputs\").size - 1,\n              },\n              {\n                field: \"witnesses\",\n                index: txSkeleton.get(\"witnesses\").size - 1,\n              },\n              {\n                field: \"headerDeps\",\n                index: txSkeleton.get(\"headerDeps\").size - 2,\n              }\n            );\n          });\n        }\n\n        if (\n          _amount.eq(0) &&\n          (changeCapacity.eq(0) || changeCapacity.gt(_minimalChangeCapacity))\n        ) {\n          break;\n        }\n      }\n    }\n  }\n\n  return {\n    txSkeleton,\n    capacity: BI.from(_amount.toString()),\n    changeCapacity: BI.from(changeCapacity.toString()),\n  };\n}\n\nasync function injectCapacityWithoutChange(\n  txSkeleton: TransactionSkeletonType,\n  fromInfos: FromInfo[],\n  amount: bigint,\n  tipHeader: Header,\n  minimalChangeCapacity: bigint,\n  {\n    config = undefined,\n    LocktimeCellCollector = CellCollector,\n    enableDeductCapacity = true,\n  }: {\n    config?: Config;\n    LocktimeCellCollector?: CellCollectorConstructor;\n    enableDeductCapacity?: boolean;\n  }\n): Promise<{\n  txSkeleton: TransactionSkeletonType;\n  capacity: bigint;\n  changeCapacity: bigint;\n}> {\n  const result = await injectCapacityWithoutChangeCompatible(\n    txSkeleton,\n    fromInfos,\n    amount,\n    tipHeader,\n    minimalChangeCapacity,\n    {\n      config,\n      LocktimeCellCollector,\n      enableDeductCapacity,\n    }\n  );\n\n  return {\n    txSkeleton: result.txSkeleton,\n    capacity: result.capacity.toBigInt(),\n    changeCapacity: result.changeCapacity.toBigInt(),\n  };\n}\n\nexport async function payFee(\n  txSkeleton: TransactionSkeletonType,\n  fromInfos: FromInfo[],\n  amount: BIish,\n  tipHeader: Header,\n  {\n    config = undefined,\n    LocktimeCellCollector = CellCollector,\n  }: {\n    config?: Config;\n    LocktimeCellCollector?: CellCollectorConstructor;\n  } = {}\n): Promise<TransactionSkeletonType> {\n  return transferCompatible(\n    txSkeleton,\n    fromInfos,\n    undefined,\n    amount,\n    tipHeader,\n    {\n      config,\n      requireToAddress: false,\n      LocktimeCellCollector,\n    }\n  );\n}\n\nexport function prepareSigningEntries(\n  txSkeleton: TransactionSkeletonType,\n  { config = undefined }: Options = {}\n): TransactionSkeletonType {\n  config = config || getConfig();\n  txSkeleton = _prepareSigningEntries(txSkeleton, config, \"SECP256K1_BLAKE160\");\n  txSkeleton = _prepareSigningEntries(\n    txSkeleton,\n    config,\n    \"SECP256K1_BLAKE160_MULTISIG\"\n  );\n  return txSkeleton;\n}\n\nexport async function injectCapacity(\n  txSkeleton: TransactionSkeletonType,\n  outputIndex: number,\n  fromInfos: FromInfo[],\n  tipHeader: Header,\n  {\n    config = undefined,\n    LocktimeCellCollector = CellCollector,\n  }: Options & {\n    // eslint-disable-next-line\n    cellCollector?: (...params: any[]) => AsyncIterable<LocktimeCell>;\n    LocktimeCellCollector?: CellCollectorConstructor;\n  } = {}\n): Promise<TransactionSkeletonType> {\n  config = config || getConfig();\n  if (outputIndex >= txSkeleton.get(\"outputs\").size) {\n    throw new Error(\"Invalid output index!\");\n  }\n  const capacity = BI.from(\n    txSkeleton.get(\"outputs\").get(outputIndex)!.cellOutput.capacity\n  );\n  return transferCompatible(\n    txSkeleton,\n    fromInfos,\n    undefined,\n    BI.from(capacity),\n    tipHeader,\n    {\n      config,\n      requireToAddress: false,\n      LocktimeCellCollector,\n    }\n  );\n}\n\nasync function collectInput(\n  txSkeleton: TransactionSkeletonType,\n  inputCell: Cell,\n  fromInfo?: FromInfo,\n  {\n    config = undefined,\n    since = undefined,\n    defaultWitness = \"0x\",\n  }: Options & { defaultWitness?: HexString; since?: PackedSince } = {}\n): Promise<TransactionSkeletonType> {\n  config = config || getConfig();\n\n  txSkeleton = await setupInputCell(txSkeleton, inputCell, fromInfo, {\n    config,\n    since,\n    defaultWitness,\n  });\n\n  txSkeleton = txSkeleton.update(\"outputs\", (outputs) => {\n    return outputs.remove(outputs.size - 1);\n  });\n\n  return txSkeleton;\n}\n\nexport async function setupInputCell(\n  txSkeleton: TransactionSkeletonType,\n  inputCell: Cell,\n  fromInfo?: FromInfo,\n  {\n    config = undefined,\n    since = undefined,\n    defaultWitness = \"0x\",\n  }: Options & { defaultWitness?: HexString; since?: PackedSince } = {}\n): Promise<TransactionSkeletonType> {\n  config = config || getConfig();\n  const inputLock = inputCell.cellOutput.lock;\n\n  if (isSecp256k1Blake160Script(inputLock, config)) {\n    return secp256k1Blake160.setupInputCell(txSkeleton, inputCell, fromInfo, {\n      config,\n      defaultWitness,\n      since,\n    });\n  } else if (isSecp256k1Blake160MultisigScript(inputLock, config)) {\n    return secp256k1Blake160Multisig.setupInputCell(\n      txSkeleton,\n      inputCell,\n      fromInfo,\n      {\n        config,\n        defaultWitness,\n        since,\n      }\n    );\n  } else {\n    throw new Error(`Not supported input lock!`);\n  }\n}\n\nfunction _parseMultisigArgsSinceCompatible(args: HexString): BI {\n  if (args.length !== 58) {\n    throw new Error(\"Invalid multisig with since args!\");\n  }\n  return number.Uint64LE.unpack(\"0x\" + args.slice(42));\n}\n\nexport default {\n  CellCollector,\n  transfer,\n  transferCompatible,\n  payFee,\n  prepareSigningEntries,\n  injectCapacity,\n  setupInputCell,\n  injectCapacityWithoutChange,\n  injectCapacityWithoutChangeCompatible,\n};\n"],"mappings":"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"}