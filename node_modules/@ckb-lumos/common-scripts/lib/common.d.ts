import { TransactionSkeletonType, Options } from "@ckb-lumos/helpers";
import { FromInfo } from "./from_info";
import { Config } from "@ckb-lumos/config-manager";
import { Address, Header, Cell, HexString, Hash, PackedSince, Transaction, HashType } from "@ckb-lumos/base";
import { BI, BIish } from "@ckb-lumos/bi";
import { CellCollectorConstructor, CellCollectorType } from "./type";
export type { CellCollectorConstructor, CellCollectorType };
/**
 * LockScriptInfo describes how to integrate a lock script in transaction building.
 *
 * Custom lock scripts must register their LockScriptInfo before using
 * `transfer`, `injectCapacity`, `payFee`, `payFeeByFeeRate` via
 * `registerCustomLockScriptInfos`.
 *
 * See an example in
 * [custom_lock_script_info.ts](https://github.com/ckb-js/lumos/blob/develop/packages/common-scripts/examples/custom_lock_script_info/custom_lock_script_info.ts).
 */
export interface LockScriptInfo {
    codeHash: Hash;
    hashType: HashType;
    /**
     * @interface
     */
    lockScriptInfo: {
        /**
         * Collects input cell candidates for the lock script.
         *
         * It's a constructor that initializes objects implementing function
         * `collect()` to provide input cells. Attention that transaction builders
         * will not match `fromInfo` and lock script. It's the responsibility of
         * `CellCollector` to filter based on `fromInfo`. For example, when
         * `fromInfo` does not match, the function `collect()` should not return
         * any cell.
         */
        CellCollector: CellCollectorConstructor;
        /**
         * Called when a candidate input cell is found.
         *
         * What this function should do:
         *
         * 1. Frist double-check the cell and decide whether continue the following steps or skip.
         * 2. Add the cell as an input in the `txSkeleton` and an output cell with
         *    the same fields since functions like `transfer`, `injectCapacity`,
         *    `payFee`, and `payFeeByFeeRate` collects account balance in outputs.
         * 3. Add `cellDeps`
         * 4. Prefill witnesses to ensure the transaction size will not increase after signing.
         *
         * @param txSkeleton transaction skeleton built so far
         * @param inputCell the new input cell candidate
         * @param fromInfo which account the inputCell belongs to
         * @return the updated transaction skeleton
         */
        setupInputCell(txSkeleton: TransactionSkeletonType, inputCell: Cell, fromInfo?: FromInfo, options?: {
            config?: Config;
            defaultWitness?: HexString;
            since?: PackedSince;
        }): Promise<TransactionSkeletonType>;
        /**
         * Scans the transaction and add signing entries into `txSkeleton.signingEnties`.
         * @return the updated txSkeleton
         */
        prepareSigningEntries(txSkeleton: TransactionSkeletonType, options: Options): TransactionSkeletonType;
        setupOutputCell?: (txSkeleton: TransactionSkeletonType, outputCell: Cell, options: Options) => Promise<TransactionSkeletonType>;
    };
}
type LockScriptInfosType = {
    configHashCode: number;
    _predefinedInfos: LockScriptInfo[];
    _customInfos: LockScriptInfo[];
    infos: LockScriptInfo[];
};
declare function resetLockScriptInfos(): void;
declare function getLockScriptInfos(): LockScriptInfosType;
/** Registers LockScriptInfo for custom scripts. */
export declare function registerCustomLockScriptInfos(infos: LockScriptInfo[]): void;
declare function generateLockScriptInfos({ config }?: Options): void;
/**
 *
 * @param txSkeleton
 * @param fromInfos
 * @param toAddress
 * @param changeAddress
 * @param amount
 * @param tipHeader will not use locktime cells if tipHeader not provided
 * @param options
 */
export declare function transfer(txSkeleton: TransactionSkeletonType, fromInfos: FromInfo[], toAddress: Address, amount: BIish, changeAddress?: Address, tipHeader?: Header, { config, useLocktimeCellsFirst, LocktimePoolCellCollector, }?: {
    config?: Config;
    useLocktimeCellsFirst?: boolean;
    LocktimePoolCellCollector?: CellCollectorConstructor;
}): Promise<TransactionSkeletonType>;
export declare function injectCapacity(txSkeleton: TransactionSkeletonType, fromInfos: FromInfo[], amount: BIish, changeAddress?: Address, tipHeader?: Header, { config, useLocktimeCellsFirst, LocktimePoolCellCollector, enableDeductCapacity, }?: {
    config?: Config;
    useLocktimeCellsFirst?: boolean;
    LocktimePoolCellCollector?: CellCollectorConstructor;
    enableDeductCapacity?: boolean;
}): Promise<TransactionSkeletonType>;
export declare function payFee(txSkeleton: TransactionSkeletonType, fromInfos: FromInfo[], amount: BIish, tipHeader?: Header, { config, useLocktimeCellsFirst, enableDeductCapacity, }?: {
    config?: Config;
    useLocktimeCellsFirst?: boolean;
    enableDeductCapacity?: boolean;
}): Promise<TransactionSkeletonType>;
export declare function prepareSigningEntries(txSkeleton: TransactionSkeletonType, { config }?: Options): TransactionSkeletonType;
declare function _commonTransfer(txSkeleton: TransactionSkeletonType, fromInfos: FromInfo[], amount: bigint, minimalChangeCapacity: bigint, { config, enableDeductCapacity, }?: Options & {
    enableDeductCapacity?: boolean;
}): Promise<{
    txSkeleton: TransactionSkeletonType;
    capacity: bigint;
    changeCapacity: bigint;
}>;
/**
 * A function to transfer input to output, and add input & output to txSkeleton.
 * And it will deal with cell deps and witnesses too. (Add the input required cell deps and witnesses.)
 * It should be noted that the output must be added to the end of txSkeleton.get("outputs").
 *
 * @param txSkeleton
 * @param inputCell
 * @param fromInfo
 * @param options
 */
export declare function setupInputCell(txSkeleton: TransactionSkeletonType, inputCell: Cell, fromInfo?: FromInfo, { config, since, defaultWitness, }?: Options & {
    since?: PackedSince;
    defaultWitness?: HexString;
}): Promise<TransactionSkeletonType>;
export declare function payFeeByFeeRate(txSkeleton: TransactionSkeletonType, fromInfos: FromInfo[], feeRate: BIish, tipHeader?: Header, { config, useLocktimeCellsFirst, enableDeductCapacity, }?: {
    config?: Config;
    useLocktimeCellsFirst?: boolean;
    enableDeductCapacity?: boolean;
}): Promise<TransactionSkeletonType>;
declare function calculateFee(size: number, feeRate: bigint): bigint;
declare function calculateFeeCompatible(size: number, feeRate: BIish): BI;
declare function getTransactionSize(txSkeleton: TransactionSkeletonType): number;
declare function getTransactionSizeByTx(tx: Transaction): number;
declare const _default: {
    transfer: typeof transfer;
    payFee: typeof payFee;
    prepareSigningEntries: typeof prepareSigningEntries;
    injectCapacity: typeof injectCapacity;
    setupInputCell: typeof setupInputCell;
    registerCustomLockScriptInfos: typeof registerCustomLockScriptInfos;
    payFeeByFeeRate: typeof payFeeByFeeRate;
    __tests__: {
        _commonTransfer: typeof _commonTransfer;
        resetLockScriptInfos: typeof resetLockScriptInfos;
        getLockScriptInfos: typeof getLockScriptInfos;
        generateLockScriptInfos: typeof generateLockScriptInfos;
        getTransactionSizeByTx: typeof getTransactionSizeByTx;
        getTransactionSize: typeof getTransactionSize;
        calculateFee: typeof calculateFee;
        calculateFeeCompatible: typeof calculateFeeCompatible;
    };
};
export default _default;
//# sourceMappingURL=common.d.ts.map