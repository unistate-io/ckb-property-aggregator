{"version":3,"file":"sudt.js","names":["_helper","require","_base","_secp256k1_blake160_multisig","_interopRequireDefault","_from_info","_common","_helpers","_immutable","_configManager","_locktime_pool","_anyone_can_pay","_interopRequireWildcard","_secp256k1_blake","_bi","_codec","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","obj","__esModule","default","cache","has","get","newObj","hasPropertyDescriptor","Object","defineProperty","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","computeScriptHash","utils","ScriptValue","values","issueToken","txSkeleton","fromInfo","amount","capacity","tipHeader","config","undefined","getConfig","template","SCRIPTS","SUDT","Error","addCellDep","outPoint","txHash","TX_HASH","index","INDEX","depType","DEP_TYPE","fromScript","parseFromInfo","toScript","sudtTypeScript","codeHash","CODE_HASH","hashType","HASH_TYPE","args","targetOutput","cellOutput","lock","type","data","bytes","hexify","number","Uint128LE","pack","blockHash","minimalCellCapacityCompatible","_capacity","BI","from","toString","update","outputs","push","outputIndex","size","fixedEntries","field","common","injectCapacity","transfer","fromInfos","sudtToken","toAddress","changeAddress","LocktimePoolCellCollector","LocktimeCellCollector","splitChangeCell","_amount","SUDT_SCRIPT","length","parseAddress","fromScripts","map","changeOutputLockScript","lte","sudtType","_generateSudtScript","cellProvider","toAddressInputCapacity","toAddressInputAmount","isAcpScript","toAddressCellCollector","AnyoneCanPayCellCollector","queryOptions","toAddressInput","collect","next","value","inputs","witnesses","unpackAmount","add","changeCell","changeCellWithoutSudt","changeCapacity","changeAmount","previousInputs","Set","input","cellCollectorInfos","List","forEach","locktimePoolCellCollector","cellCollector","secpCollector","secp256k1Blake160","CellCollector","multisigCollector","secp256k1Blake160Multisig","acpCollector","anyoneCanPay","isAnyoneCanPay","destroyable","locktimeCellCollector","inputCell","setupInputCell","lastOutputIndex","remove","fixedEntryIndex","findIndex","fixedEntry","inputCapacity","inputAmount","deductCapacity","sub","deductAmount","gt","currentChangeCapacity","currentChangeAmount","acpChangeCell","eq","changeOutputIndex","output","validate","equals","gte","originOutput","clonedOutput","JSON","parse","stringify","minimalChangeCellCapcaity","minimalChangeCellWithoutSudtCapacity","splitFlag","lt","token","ownerForSudt","lockHash","unpack","bytify","slice","packAmount","_default","exports"],"sources":["../src/sudt.ts"],"sourcesContent":["import { addCellDep, isAcpScript } from \"./helper\";\nimport {\n  utils,\n  Hash,\n  Address,\n  Cell,\n  Script,\n  Header,\n  CellCollector as CellCollectorInterface,\n  values,\n  HexString,\n} from \"@ckb-lumos/base\";\nconst { computeScriptHash } = utils;\nimport secp256k1Blake160Multisig from \"./secp256k1_blake160_multisig\";\nimport { FromInfo, parseFromInfo } from \"./from_info\";\nimport common from \"./common\";\nimport {\n  parseAddress,\n  TransactionSkeletonType,\n  Options,\n  minimalCellCapacityCompatible,\n} from \"@ckb-lumos/helpers\";\nimport { Set, List } from \"immutable\";\nimport { getConfig, Config } from \"@ckb-lumos/config-manager\";\nimport { CellCollector as LocktimeCellCollector } from \"./locktime_pool\";\nimport anyoneCanPay, {\n  CellCollector as AnyoneCanPayCellCollector,\n} from \"./anyone_can_pay\";\nconst { ScriptValue } = values;\nimport secp256k1Blake160 from \"./secp256k1_blake160\";\nimport { BI, BIish } from \"@ckb-lumos/bi\";\nimport { bytes, type BytesLike, number } from \"@ckb-lumos/codec\";\n\nexport type Token = Hash;\n\n/**\n * Issue an sUDT cell\n *\n * @param txSkeleton\n * @param fromInfo\n * @param amount\n * @param capacity\n * @param tipHeader\n * @param options\n */\nexport async function issueToken(\n  txSkeleton: TransactionSkeletonType,\n  fromInfo: FromInfo,\n  amount: BIish,\n  capacity?: BIish,\n  tipHeader?: Header,\n  { config = undefined }: Options = {}\n): Promise<TransactionSkeletonType> {\n  config = config || getConfig();\n  const template = config.SCRIPTS.SUDT;\n\n  if (!template) {\n    throw new Error(\"Provided config does not have SUDT script setup!\");\n  }\n\n  txSkeleton = addCellDep(txSkeleton, {\n    outPoint: {\n      txHash: template.TX_HASH,\n      index: template.INDEX,\n    },\n    depType: template.DEP_TYPE,\n  });\n\n  const fromScript = parseFromInfo(fromInfo, { config }).fromScript;\n\n  const toScript = fromScript;\n\n  const sudtTypeScript = {\n    codeHash: template.CODE_HASH,\n    hashType: template.HASH_TYPE,\n    args: computeScriptHash(fromScript),\n  };\n\n  const targetOutput: Cell = {\n    cellOutput: {\n      capacity: \"0x0\",\n      lock: toScript,\n      type: sudtTypeScript,\n    },\n    data: bytes.hexify(number.Uint128LE.pack(amount)),\n    outPoint: undefined,\n    blockHash: undefined,\n  };\n\n  if (!capacity) {\n    capacity = minimalCellCapacityCompatible(targetOutput);\n  }\n  const _capacity = BI.from(capacity);\n  targetOutput.cellOutput.capacity = \"0x\" + _capacity.toString(16);\n\n  txSkeleton = txSkeleton.update(\"outputs\", (outputs) => {\n    return outputs.push(targetOutput);\n  });\n\n  const outputIndex = txSkeleton.get(\"outputs\").size - 1;\n\n  // fix entry\n  txSkeleton = txSkeleton.update(\"fixedEntries\", (fixedEntries) => {\n    return fixedEntries.push({\n      field: \"outputs\",\n      index: outputIndex,\n    });\n  });\n\n  txSkeleton = await common.injectCapacity(\n    txSkeleton,\n    [fromInfo],\n    BI.from(BI.from(targetOutput.cellOutput.capacity)),\n    undefined,\n    tipHeader,\n    {\n      config,\n    }\n  );\n\n  return txSkeleton;\n}\n\n/**\n *\n * @param txSkeleton\n * @param fromInfos\n * @param sudtToken\n * @param toAddress\n * @param amount\n * @param changeAddress if not provided, will use first fromInfo\n * @param capacity\n * @param tipHeader\n * @param options When `splitChangeCell = true` && change amount > 0 && change capacity >= minimalCellCapacity(change cell with sudt) + minimalCellCapacity(change cell without sudt), change cell will split to two change cells, one with sudt and one without.\n */\nexport async function transfer(\n  txSkeleton: TransactionSkeletonType,\n  fromInfos: FromInfo[],\n  sudtToken: Token,\n  toAddress: Address,\n  amount: BIish,\n  changeAddress?: Address,\n  capacity?: BIish,\n  tipHeader?: Header,\n  {\n    config = undefined,\n    LocktimePoolCellCollector = LocktimeCellCollector,\n    splitChangeCell = false,\n  }: Options & {\n    //eslint-disable-next-line @typescript-eslint/no-explicit-any\n    LocktimePoolCellCollector?: any;\n    splitChangeCell?: boolean;\n  } = {}\n): Promise<TransactionSkeletonType> {\n  config = config || getConfig();\n  let _amount = BI.from(amount);\n  let _capacity = capacity ? BI.from(capacity) : undefined;\n\n  const SUDT_SCRIPT = config.SCRIPTS.SUDT;\n\n  if (!SUDT_SCRIPT) {\n    throw new Error(\"Provided config does not have SUDT script setup!\");\n  }\n\n  if (fromInfos.length === 0) {\n    throw new Error(\"`fromInfos` can't be empty!\");\n  }\n\n  if (!toAddress) {\n    throw new Error(\"You must provide a to address!\");\n  }\n  const toScript = parseAddress(toAddress, { config });\n\n  const fromScripts: Script[] = fromInfos.map(\n    (fromInfo) => parseFromInfo(fromInfo, { config }).fromScript\n  );\n  const changeOutputLockScript = changeAddress\n    ? parseAddress(changeAddress, { config })\n    : fromScripts[0];\n\n  if (_amount.lte(0)) {\n    throw new Error(\"amount must be greater than 0\");\n  }\n\n  const sudtType = _generateSudtScript(sudtToken, config);\n\n  const cellProvider = txSkeleton.get(\"cellProvider\");\n  if (!cellProvider) {\n    throw new Error(\"Cell provider is missing!\");\n  }\n\n  // if toScript is an anyone-can-pay script\n  let toAddressInputCapacity: BI = BI.from(0);\n  let toAddressInputAmount: BI = BI.from(0);\n  if (isAcpScript(toScript, config)) {\n    const toAddressCellCollector = new AnyoneCanPayCellCollector(\n      toAddress,\n      cellProvider,\n      {\n        config,\n        queryOptions: {\n          type: sudtType,\n          data: \"any\",\n        },\n      }\n    );\n\n    const toAddressInput: Cell | void = (\n      await toAddressCellCollector.collect().next()\n    ).value;\n    if (!toAddressInput) {\n      throw new Error(`toAddress ANYONE_CAN_PAY input not found!`);\n    }\n\n    txSkeleton = txSkeleton.update(\"inputs\", (inputs) => {\n      return inputs.push(toAddressInput);\n    });\n\n    txSkeleton = txSkeleton.update(\"witnesses\", (witnesses) => {\n      return witnesses.push(\"0x\");\n    });\n\n    toAddressInputCapacity = BI.from(toAddressInput.cellOutput.capacity);\n    toAddressInputAmount = unpackAmount(toAddressInput.data);\n  }\n\n  const targetOutput: Cell = {\n    cellOutput: {\n      capacity: \"0x0\",\n      lock: toScript,\n      type: sudtType,\n    },\n    data: bytes.hexify(number.Uint128LE.pack(_amount)),\n    outPoint: undefined,\n    blockHash: undefined,\n  };\n  if (isAcpScript(toScript, config)) {\n    if (!_capacity) {\n      _capacity = BI.from(0);\n    }\n    targetOutput.cellOutput.capacity =\n      \"0x\" + toAddressInputCapacity.add(_capacity).toString(16);\n    targetOutput.data = bytes.hexify(\n      number.Uint128LE.pack(toAddressInputAmount.add(_amount))\n    );\n  } else {\n    if (!_capacity) {\n      _capacity = BI.from(minimalCellCapacityCompatible(targetOutput));\n    }\n    targetOutput.cellOutput.capacity = \"0x\" + _capacity.toString(16);\n  }\n\n  // collect cells with which includes sUDT info\n  txSkeleton = txSkeleton.update(\"outputs\", (outputs) => {\n    return outputs.push(targetOutput);\n  });\n\n  txSkeleton = txSkeleton.update(\"fixedEntries\", (fixedEntries) => {\n    return fixedEntries.push({\n      field: \"outputs\",\n      index: txSkeleton.get(\"outputs\").size - 1,\n    });\n  });\n\n  txSkeleton = addCellDep(txSkeleton, {\n    outPoint: {\n      txHash: SUDT_SCRIPT.TX_HASH,\n      index: SUDT_SCRIPT.INDEX,\n    },\n    depType: SUDT_SCRIPT.DEP_TYPE,\n  });\n\n  // collect cells\n  const changeCell: Cell = {\n    cellOutput: {\n      capacity: \"0x0\",\n      lock: changeOutputLockScript,\n      type: sudtType,\n    },\n    data: bytes.hexify(number.Uint128LE.pack(0)),\n    outPoint: undefined,\n    blockHash: undefined,\n  };\n  const changeCellWithoutSudt: Cell = {\n    cellOutput: {\n      capacity: \"0x0\",\n      lock: changeOutputLockScript,\n      type: undefined,\n    },\n    data: \"0x\",\n    outPoint: undefined,\n    blockHash: undefined,\n  };\n  let changeCapacity = BI.from(0);\n  let changeAmount = BI.from(0);\n  let previousInputs = Set<string>();\n  for (const input of txSkeleton.get(\"inputs\")) {\n    previousInputs = previousInputs.add(\n      `${input.outPoint!.txHash}_${input.outPoint!.index}`\n    );\n  }\n  let cellCollectorInfos: List<{\n    cellCollector: CellCollectorInterface;\n    index: number;\n    isAnyoneCanPay?: boolean;\n    destroyable?: boolean;\n  }> = List();\n  if (tipHeader) {\n    fromInfos.forEach((fromInfo, index) => {\n      const locktimePoolCellCollector = new LocktimePoolCellCollector(\n        fromInfo,\n        cellProvider,\n        {\n          config,\n          tipHeader,\n          queryOptions: {\n            type: sudtType,\n            data: \"any\",\n          },\n        }\n      );\n\n      cellCollectorInfos = cellCollectorInfos.push({\n        cellCollector: locktimePoolCellCollector,\n        index,\n      });\n    });\n  }\n  fromInfos.forEach((fromInfo, index) => {\n    const secpCollector = new secp256k1Blake160.CellCollector(\n      fromInfo,\n      cellProvider,\n      {\n        config,\n        queryOptions: {\n          type: sudtType,\n          data: \"any\",\n        },\n      }\n    );\n    const multisigCollector = new secp256k1Blake160Multisig.CellCollector(\n      fromInfo,\n      cellProvider,\n      {\n        config,\n        queryOptions: {\n          type: sudtType,\n          data: \"any\",\n        },\n      }\n    );\n    const acpCollector = new anyoneCanPay.CellCollector(\n      fromInfo,\n      cellProvider,\n      {\n        config,\n        queryOptions: {\n          type: sudtType,\n          data: \"any\",\n        },\n      }\n    );\n\n    cellCollectorInfos = cellCollectorInfos.push(\n      {\n        cellCollector: secpCollector,\n        index,\n      },\n      {\n        cellCollector: multisigCollector,\n        index,\n      },\n      {\n        cellCollector: acpCollector,\n        index,\n        isAnyoneCanPay: true,\n        destroyable: parseFromInfo(fromInfo, { config }).destroyable,\n      }\n    );\n  });\n  if (tipHeader) {\n    fromInfos.forEach((fromInfo, index) => {\n      const locktimeCellCollector = new LocktimePoolCellCollector(\n        fromInfo,\n        cellProvider,\n        {\n          config,\n          tipHeader,\n        }\n      );\n\n      cellCollectorInfos = cellCollectorInfos.push({\n        cellCollector: locktimeCellCollector,\n        index,\n      });\n    });\n  }\n  fromInfos.forEach((fromInfo, index) => {\n    const secpCollector = new secp256k1Blake160.CellCollector(\n      fromInfo,\n      cellProvider,\n      {\n        config,\n      }\n    );\n    const multisigCollector = new secp256k1Blake160Multisig.CellCollector(\n      fromInfo,\n      cellProvider,\n      {\n        config,\n      }\n    );\n    const acpCollector = new anyoneCanPay.CellCollector(\n      fromInfo,\n      cellProvider,\n      {\n        config,\n      }\n    );\n\n    cellCollectorInfos = cellCollectorInfos.push(\n      {\n        cellCollector: secpCollector,\n        index,\n      },\n      {\n        cellCollector: multisigCollector,\n        index,\n      },\n      {\n        cellCollector: acpCollector,\n        index,\n        isAnyoneCanPay: true,\n        destroyable: parseFromInfo(fromInfo, { config }).destroyable,\n      }\n    );\n  });\n  for (const {\n    index,\n    cellCollector,\n    isAnyoneCanPay,\n    destroyable,\n  } of cellCollectorInfos) {\n    for await (const inputCell of cellCollector.collect()) {\n      // skip inputs already exists in txSkeleton.inputs\n      const key = `${inputCell.outPoint!.txHash}_${inputCell.outPoint!.index}`;\n      if (previousInputs.has(key)) {\n        continue;\n      }\n      previousInputs = previousInputs.add(key);\n\n      const fromInfo = fromInfos[index];\n      txSkeleton = await common.setupInputCell(\n        txSkeleton,\n        inputCell,\n        fromInfo,\n        {\n          config,\n        }\n      );\n      // remove output which added by `setupInputCell`\n      const lastOutputIndex: number = txSkeleton.get(\"outputs\").size - 1;\n      txSkeleton = txSkeleton.update(\"outputs\", (outputs) => {\n        return outputs.remove(lastOutputIndex);\n      });\n      // remove output fixedEntry\n      const fixedEntryIndex: number = txSkeleton\n        .get(\"fixedEntries\")\n        .findIndex((fixedEntry) => {\n          return (\n            fixedEntry.field === \"outputs\" &&\n            fixedEntry.index === lastOutputIndex\n          );\n        });\n      if (fixedEntryIndex >= 0) {\n        txSkeleton = txSkeleton.update(\"fixedEntries\", (fixedEntries) => {\n          return fixedEntries.remove(fixedEntryIndex);\n        });\n      }\n\n      const inputCapacity: BI = BI.from(inputCell.cellOutput.capacity);\n      const inputAmount: BI = inputCell.cellOutput.type\n        ? unpackAmount(inputCell.data)\n        : BI.from(0);\n      let deductCapacity: BI =\n        isAnyoneCanPay && !destroyable\n          ? inputCapacity.sub(minimalCellCapacityCompatible(inputCell))\n          : inputCapacity;\n      let deductAmount: BI = inputAmount;\n      if (deductCapacity.gt(_capacity)) {\n        deductCapacity = BI.from(_capacity);\n      }\n      _capacity = _capacity.sub(deductCapacity);\n      const currentChangeCapacity: BI = inputCapacity.sub(deductCapacity);\n      if (!isAnyoneCanPay || (isAnyoneCanPay && destroyable)) {\n        changeCapacity = changeCapacity.add(currentChangeCapacity);\n      }\n      if (deductAmount.gt(_amount)) {\n        deductAmount = _amount;\n      }\n      _amount = _amount.sub(deductAmount);\n      const currentChangeAmount: BI = inputAmount.sub(deductAmount);\n      if (!isAnyoneCanPay || (isAnyoneCanPay && destroyable)) {\n        changeAmount = changeAmount.add(currentChangeAmount);\n      }\n\n      if (isAnyoneCanPay && !destroyable) {\n        const acpChangeCell: Cell = {\n          cellOutput: {\n            capacity: \"0x\" + currentChangeCapacity.toString(16),\n            lock: inputCell.cellOutput.lock,\n            type: inputCell.cellOutput.type,\n          },\n          data: inputCell.cellOutput.type\n            ? bytes.hexify(number.Uint128LE.pack(currentChangeAmount))\n            : \"0x\",\n        };\n\n        txSkeleton = txSkeleton.update(\"outputs\", (outputs) => {\n          return outputs.push(acpChangeCell);\n        });\n\n        if (inputCell.cellOutput.type) {\n          txSkeleton = txSkeleton.update(\"fixedEntries\", (fixedEntries) => {\n            return fixedEntries.push({\n              field: \"outputs\",\n              index: txSkeleton.get(\"outputs\").size - 1,\n            });\n          });\n        }\n      }\n\n      // changeAmount = 0n, the change output no need to include sudt type script\n      if (\n        _capacity.eq(0) &&\n        _amount.eq(0) &&\n        ((changeCapacity.eq(0) && changeAmount.eq(0)) ||\n          (changeCapacity.gt(\n            minimalCellCapacityCompatible(changeCellWithoutSudt)\n          ) &&\n            changeAmount.eq(0)))\n      ) {\n        changeCell.cellOutput.type = undefined;\n        changeCell.data = \"0x\";\n        break;\n      }\n      if (\n        _capacity.eq(0) &&\n        _amount.eq(0) &&\n        changeCapacity.gt(\n          minimalCellCapacityCompatible(changeCellWithoutSudt)\n        ) &&\n        changeAmount.gt(0)\n      ) {\n        break;\n      }\n    }\n  }\n\n  // if change cell is an anyone-can-pay cell and exists in txSkeleton.get(\"outputs\") and not in fixedEntries\n  // 1. change lock script is acp\n  // 2. lock and type are equal to output OutputA in outputs\n  // 3. OutputA is not fixed.\n  let changeOutputIndex = -1;\n  if (\n    isAcpScript(changeCell.cellOutput.lock, config) &&\n    (changeOutputIndex = txSkeleton.get(\"outputs\").findIndex((output) => {\n      return (\n        new ScriptValue(changeCell.cellOutput.lock, {\n          validate: false,\n        }).equals(\n          new ScriptValue(output.cellOutput.lock, { validate: false })\n        ) &&\n        ((changeAmount.eq(0) &&\n          !changeCell.cellOutput.type &&\n          !output.cellOutput.type) ||\n          (changeAmount.gte(0) &&\n            !!changeCell.cellOutput.type &&\n            !!output.cellOutput.type &&\n            new ScriptValue(changeCell.cellOutput.type, {\n              validate: false,\n            }).equals(\n              new ScriptValue(output.cellOutput.type, { validate: false })\n            )))\n      );\n    })) !== -1 &&\n    txSkeleton.get(\"fixedEntries\").findIndex((fixedEntry) => {\n      return (\n        fixedEntry.field === \"output\" && fixedEntry.index === changeOutputIndex\n      );\n    }) === -1\n  ) {\n    const originOutput: Cell = txSkeleton\n      .get(\"outputs\")\n      .get(changeOutputIndex)!;\n    const clonedOutput: Cell = JSON.parse(JSON.stringify(originOutput));\n    clonedOutput.cellOutput.capacity =\n      \"0x\" +\n      BI.from(originOutput.cellOutput.capacity)\n        .add(changeCapacity)\n        .toString(16);\n    if (changeAmount.gt(0)) {\n      clonedOutput.data = bytes.hexify(\n        number.Uint128LE.pack(unpackAmount(originOutput.data).add(changeAmount))\n      );\n    }\n\n    const minimalChangeCellCapcaity = BI.from(\n      minimalCellCapacityCompatible(changeCell)\n    );\n    const minimalChangeCellWithoutSudtCapacity = BI.from(\n      minimalCellCapacityCompatible(changeCellWithoutSudt)\n    );\n    let splitFlag = false;\n    if (\n      changeAmount.gt(0) &&\n      splitChangeCell &&\n      changeCapacity.gte(\n        minimalChangeCellCapcaity.add(minimalChangeCellWithoutSudtCapacity)\n      )\n    ) {\n      clonedOutput.cellOutput.capacity = originOutput.cellOutput.capacity;\n      changeCellWithoutSudt.cellOutput.capacity =\n        \"0x\" + changeCapacity.toString(16);\n      splitFlag = true;\n    }\n\n    txSkeleton = txSkeleton.update(\"outputs\", (outputs) => {\n      return outputs.set(changeOutputIndex, clonedOutput);\n    });\n\n    if (splitFlag) {\n      txSkeleton = txSkeleton.update(\"outputs\", (outputs) => {\n        return outputs.push(changeCellWithoutSudt);\n      });\n    }\n  } else if (changeCapacity.gte(minimalCellCapacityCompatible(changeCell))) {\n    changeCell.cellOutput.capacity = \"0x\" + changeCapacity.toString(16);\n    if (changeAmount.gt(0)) {\n      changeCell.data = bytes.hexify(number.Uint128LE.pack(changeAmount));\n    }\n\n    const minimalChangeCellCapcaity = BI.from(\n      minimalCellCapacityCompatible(changeCell)\n    );\n    const minimalChangeCellWithoutSudtCapacity = BI.from(\n      minimalCellCapacityCompatible(changeCellWithoutSudt)\n    );\n    let splitFlag = false;\n    if (changeAmount.gt(0) && splitChangeCell) {\n      if (\n        changeCapacity.gte(\n          minimalChangeCellCapcaity.add(minimalChangeCellWithoutSudtCapacity)\n        )\n      ) {\n        changeCell.cellOutput.capacity =\n          \"0x\" + minimalChangeCellCapcaity.toString(16);\n        changeCellWithoutSudt.cellOutput.capacity =\n          \"0x\" + changeCapacity.sub(minimalChangeCellCapcaity).toString(16);\n        splitFlag = true;\n      }\n    }\n\n    txSkeleton = txSkeleton.update(\"outputs\", (outputs) =>\n      outputs.push(changeCell)\n    );\n    if (changeAmount.gt(0)) {\n      txSkeleton = txSkeleton.update(\"fixedEntries\", (fixedEntries) => {\n        return fixedEntries.push({\n          field: \"outputs\",\n          index: txSkeleton.get(\"outputs\").size - 1,\n        });\n      });\n    }\n    if (splitFlag) {\n      txSkeleton = txSkeleton.update(\"outputs\", (outputs) => {\n        return outputs.push(changeCellWithoutSudt);\n      });\n    }\n  } else if (\n    changeAmount.gt(0) &&\n    changeCapacity.lt(minimalCellCapacityCompatible(changeCell))\n  ) {\n    throw new Error(\"Not enough capacity for change in from infos!\");\n  }\n  if (_capacity.gt(0)) {\n    throw new Error(\"Not enough capacity in from infos!\");\n  }\n  if (_amount.gt(0)) {\n    throw new Error(\"Not enough amount in from infos!\");\n  }\n\n  return txSkeleton;\n}\n\nfunction _generateSudtScript(token: Hash, config: Config): Script {\n  const SUDT_SCRIPT = config.SCRIPTS.SUDT!;\n  // TODO: check token is a valid hash\n  return {\n    codeHash: SUDT_SCRIPT.CODE_HASH,\n    hashType: SUDT_SCRIPT.HASH_TYPE,\n    args: token,\n  };\n}\n\n/**\n * Compute sudt token by owner from info.\n *\n * @param fromInfo\n * @param options\n */\nexport function ownerForSudt(\n  fromInfo: FromInfo,\n  { config = undefined }: Options = {}\n): Token {\n  config = config || getConfig();\n  const { fromScript } = parseFromInfo(fromInfo, { config });\n  const lockHash = computeScriptHash(fromScript);\n  return lockHash;\n}\n\nexport function unpackAmount(data: BytesLike): BI {\n  return number.Uint128LE.unpack(bytes.bytify(data).slice(0, 16));\n}\n\nexport function packAmount(amount: BIish): HexString {\n  return bytes.hexify(number.Uint128LE.pack(amount));\n}\n\nexport default {\n  issueToken,\n  transfer,\n  ownerForSudt,\n  packAmount,\n  unpackAmount,\n};\n"],"mappings":"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"}