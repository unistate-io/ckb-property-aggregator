{"version":3,"file":"index.js","names":["_crypto","_interopRequireDefault","require","_word_list","obj","__esModule","default","RADIX","PBKDF2_ROUNDS","KEY_LEN","MIN_ENTROPY_SIZE","MAX_ENTROPY_SIZE","MIN_WORDS_SIZE","MAX_WORDS_SIZE","INVALID_MNEMONIC","INVALID_CHECKSUM","ENTROPY_NOT_DIVISIBLE","ENTROPY_TOO_LONG","ENTROPY_TOO_SHORT","WORDS_TOO_LONG","WORDS_TOO_SHORT","wordList","length","Error","bytesToBinary","bytes","reduce","binary","byte","toString","padStart","deriveChecksumBits","entropyBuffer","ENT","CS","hash","crypto","createHash","update","digest","slice","salt","password","mnemonicToSeedSync","mnemonic","mnemonicBuffer","Buffer","from","normalize","saltBuffer","pbkdf2Sync","mnemonicToSeed","Promise","resolve","reject","pbkdf2","err","data","error","mnemonicToEntropy","words","split","bits","map","word","index","indexOf","join","dividerIndex","Math","floor","entropyBits","checksumBits","entropyBytes","match","parseInt","entropy","newChecksum","entropyToMnemonic","entropyStr","TypeError","checksumBytes","chunks","validateMnemonic","e","generateMnemonic","entropySize","randomBytes","_default","exports"],"sources":["../../src/mnemonic/index.ts"],"sourcesContent":["import crypto from \"crypto\";\nimport wordList from \"./word_list\";\nimport { HexString } from \"@ckb-lumos/base\";\n\nconst RADIX = 2048;\nconst PBKDF2_ROUNDS = 2048;\nconst KEY_LEN = 64;\nconst MIN_ENTROPY_SIZE = 16;\nconst MAX_ENTROPY_SIZE = 32;\nconst MIN_WORDS_SIZE = 12;\nconst MAX_WORDS_SIZE = 24;\n\nconst INVALID_MNEMONIC = `Invalid mnemonic`;\nconst INVALID_CHECKSUM = `Invalid checksum`;\nconst ENTROPY_NOT_DIVISIBLE = `Entropy should be divisable by 4`;\nconst ENTROPY_TOO_LONG = `Entropy should be shorter than ${\n  MAX_ENTROPY_SIZE + 1\n}`;\nconst ENTROPY_TOO_SHORT = `Entropy should be longer than ${\n  MIN_ENTROPY_SIZE - 1\n}`;\nconst WORDS_TOO_LONG = `Words should be shorter than ${MAX_WORDS_SIZE + 1}`;\nconst WORDS_TOO_SHORT = `Words should be longer than ${MIN_WORDS_SIZE - 1}`;\n\nif (wordList.length !== RADIX) {\n  throw new Error(\n    `Word list should have ${RADIX} words, but ${wordList.length} received in fact`\n  );\n}\n\nfunction bytesToBinary(bytes: Buffer): string {\n  return bytes.reduce((binary, byte) => {\n    return binary + byte.toString(2).padStart(8, \"0\");\n  }, \"\");\n}\n\nfunction deriveChecksumBits(entropyBuffer: Buffer): string {\n  const ENT = entropyBuffer.length * 8;\n  const CS = ENT / 32;\n  const hash = crypto.createHash(\"sha256\").update(entropyBuffer).digest();\n  return bytesToBinary(hash).slice(0, CS);\n}\n\nfunction salt(password: string = \"\"): string {\n  return `mnemonic${password}`;\n}\n\nexport function mnemonicToSeedSync(\n  mnemonic: string = \"\",\n  password: string = \"\"\n): Buffer {\n  const mnemonicBuffer = Buffer.from(mnemonic.normalize(\"NFKD\"), \"utf8\");\n  const saltBuffer = Buffer.from(salt(password.normalize(\"NFKD\")), \"utf8\");\n  return crypto.pbkdf2Sync(\n    mnemonicBuffer,\n    saltBuffer,\n    PBKDF2_ROUNDS,\n    KEY_LEN,\n    \"sha512\"\n  );\n}\n\nexport function mnemonicToSeed(\n  mnemonic: string = \"\",\n  password: string = \"\"\n): Promise<Buffer> {\n  return new Promise((resolve, reject) => {\n    try {\n      const mnemonicBuffer = Buffer.from(mnemonic.normalize(\"NFKD\"), \"utf8\");\n      const saltBuffer = Buffer.from(salt(password.normalize(\"NFKD\")), \"utf8\");\n      crypto.pbkdf2(\n        mnemonicBuffer,\n        saltBuffer,\n        PBKDF2_ROUNDS,\n        KEY_LEN,\n        \"sha512\",\n        (err, data) => {\n          if (err) {\n            reject(err);\n          }\n          resolve(data);\n        }\n      );\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n\nexport function mnemonicToEntropy(mnemonic: string = \"\"): HexString {\n  const words = mnemonic.normalize(\"NFKD\").split(\" \");\n  if (words.length < MIN_WORDS_SIZE) {\n    throw new Error(WORDS_TOO_SHORT);\n  }\n  if (words.length > MAX_WORDS_SIZE) {\n    throw new Error(WORDS_TOO_LONG);\n  }\n  if (words.length % 3 !== 0) {\n    throw new Error(INVALID_MNEMONIC);\n  }\n  const bits = words\n    .map((word) => {\n      const index = wordList!.indexOf(word);\n      if (index === -1) {\n        throw new Error(INVALID_MNEMONIC);\n      }\n      return index.toString(2).padStart(11, \"0\");\n    })\n    .join(\"\");\n\n  const dividerIndex = Math.floor(bits.length / 33) * 32;\n  const entropyBits = bits.slice(0, dividerIndex);\n  const checksumBits = bits.slice(dividerIndex);\n\n  const entropyBytes = entropyBits\n    .match(/(.{1,8})/g)!\n    .map((byte) => parseInt(byte, 2));\n  if (entropyBytes.length < MIN_ENTROPY_SIZE) {\n    throw new Error(ENTROPY_TOO_SHORT);\n  }\n  if (entropyBytes.length > MAX_ENTROPY_SIZE) {\n    throw new Error(ENTROPY_TOO_LONG);\n  }\n  if (entropyBytes.length % 4 !== 0) {\n    throw new Error(ENTROPY_NOT_DIVISIBLE);\n  }\n\n  const entropy = Buffer.from(entropyBytes);\n  const newChecksum = deriveChecksumBits(entropy);\n  if (newChecksum !== checksumBits) {\n    throw new Error(INVALID_CHECKSUM);\n  }\n\n  return \"0x\" + entropy.toString(\"hex\");\n}\n\nexport function entropyToMnemonic(entropyStr: HexString): string {\n  const entropy = Buffer.from(entropyStr.slice(2), \"hex\");\n\n  if (entropy.length < MIN_ENTROPY_SIZE) {\n    throw new TypeError(ENTROPY_TOO_SHORT);\n  }\n  if (entropy.length > MAX_ENTROPY_SIZE) {\n    throw new TypeError(ENTROPY_TOO_LONG);\n  }\n  if (entropy.length % 4 !== 0) {\n    throw new TypeError(ENTROPY_NOT_DIVISIBLE);\n  }\n\n  const entropyBytes = bytesToBinary(entropy);\n  const checksumBytes = deriveChecksumBits(entropy);\n\n  const bytes = entropyBytes + checksumBytes;\n  const chunks = bytes.match(/(.{1,11})/g)!;\n  const words = chunks.map((binary) => {\n    const index = parseInt(binary, 2);\n    return wordList[index];\n  });\n\n  return words.join(\" \");\n}\n\nexport function validateMnemonic(mnemonic: string): boolean {\n  try {\n    mnemonicToEntropy(mnemonic);\n  } catch (e) {\n    return false;\n  }\n  return true;\n}\n\n// Generate 12 words mnemonic code\nexport function generateMnemonic(): string {\n  const entropySize = 16;\n  const entropy: HexString =\n    \"0x\" + crypto.randomBytes(entropySize).toString(\"hex\");\n  return entropyToMnemonic(entropy);\n}\n\nexport default {\n  entropyToMnemonic,\n  mnemonicToEntropy,\n  mnemonicToSeed,\n  mnemonicToSeedSync,\n  validateMnemonic,\n  generateMnemonic,\n};\n"],"mappings":"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"}