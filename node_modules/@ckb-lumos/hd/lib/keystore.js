"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.UnsupportedCipher = exports.InvalidKeystore = exports.IncorrectPassword = void 0;
var _crypto = _interopRequireDefault(require("crypto"));
var _sha = require("sha3");
var _uuid = require("uuid");
var _extended_key = require("./extended_key");
var _scryptJs = require("scrypt-js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
class UnsupportedCipher extends Error {
  constructor() {
    super("Unsupported cipher!");
  }
}
exports.UnsupportedCipher = UnsupportedCipher;
class IncorrectPassword extends Error {
  constructor() {
    super("Incorrect password!");
  }
}
exports.IncorrectPassword = IncorrectPassword;
class InvalidKeystore extends Error {
  constructor() {
    super("Invalid keystore, please check your file integrity.");
  }
}
exports.InvalidKeystore = InvalidKeystore;
const CIPHER = "aes-128-ctr";
const CKB_CLI_ORIGIN = "ckb-cli";
// Encrypt and save master extended private key.
class Keystore {
  constructor(theCrypto, id, origin) {
    _defineProperty(this, "version", 3);
    this.crypto = theCrypto;
    this.id = id;
    this.origin = origin;
  }
  static fromJson(json) {
    try {
      const object = JSON.parse(json);
      return new Keystore(object.crypto, object.id, object.origin);
    } catch {
      throw new InvalidKeystore();
    }
  }

  /**
   * @deprecated
   * Load keystore file from path.
   *
   * @param path
   */
  static load(path) {
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    const fs = require("fs");
    const json = fs.readFileSync(path, "utf-8");
    return this.fromJson(json);
  }

  /**
   * @deprecated
   * Keystore file default name is `${id}.json`.
   *
   * @param dir
   * @param options If you are sure to overwrite existing keystore file, set `overwrite` to true.
   */
  save(dir, {
    name = this.filename(),
    overwrite = false
  } = {}) {
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    const fs = require("fs");
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    const Path = require("path");
    const path = Path.join(dir, name);
    if (!overwrite && fs.existsSync(path)) {
      throw new Error("Keystore file already exists!");
    }
    fs.writeFileSync(path, this.toJson());
  }
  filename() {
    return this.id + ".json";
  }
  toJson() {
    return JSON.stringify(this);
  }
  isFromCkbCli() {
    return this.origin === CKB_CLI_ORIGIN;
  }

  // Create an empty keystore object that contains empty private key
  static createEmpty() {
    const salt = _crypto.default.randomBytes(32);
    const iv = _crypto.default.randomBytes(16);
    const kdfparams = {
      dklen: 32,
      salt: salt.toString("hex"),
      n: 2 ** 18,
      r: 8,
      p: 1
    };
    return new Keystore({
      ciphertext: "",
      cipherparams: {
        iv: iv.toString("hex")
      },
      cipher: CIPHER,
      kdf: "scrypt",
      kdfparams,
      mac: ""
    }, (0, _uuid.v4)());
  }
  static create(extendedPrivateKey, password, options = {}) {
    const salt = options.salt || _crypto.default.randomBytes(32);
    const iv = options.iv || _crypto.default.randomBytes(16);
    const kdfparams = {
      dklen: 32,
      salt: salt.toString("hex"),
      n: 2 ** 18,
      r: 8,
      p: 1
    };
    const derivedKey = Buffer.from((0, _scryptJs.syncScrypt)(Buffer.from(password), salt, kdfparams.n, kdfparams.r, kdfparams.p, kdfparams.dklen));
    const cipher = _crypto.default.createCipheriv(CIPHER, derivedKey.slice(0, 16), iv);
    if (!cipher) {
      throw new UnsupportedCipher();
    }
    const ciphertext = Buffer.concat([cipher.update(Buffer.from(extendedPrivateKey.serialize().slice(2), "hex")), cipher.final()]);
    return new Keystore({
      ciphertext: ciphertext.toString("hex"),
      cipherparams: {
        iv: iv.toString("hex")
      },
      cipher: CIPHER,
      kdf: "scrypt",
      kdfparams,
      mac: Keystore.mac(derivedKey, ciphertext)
    }, (0, _uuid.v4)());
  }

  // Imported from xpub with empty private key.
  isEmpty() {
    return this.crypto.ciphertext === "" && this.crypto.mac === "";
  }

  // Decrypt and return serialized extended private key.
  decrypt(password) {
    const derivedKey = this.derivedKey(password);
    const ciphertext = Buffer.from(this.crypto.ciphertext, "hex");
    if (Keystore.mac(derivedKey, ciphertext) !== this.crypto.mac) {
      throw new IncorrectPassword();
    }
    const decipher = _crypto.default.createDecipheriv(this.crypto.cipher, derivedKey.slice(0, 16), Buffer.from(this.crypto.cipherparams.iv, "hex"));
    return "0x" + Buffer.concat([decipher.update(ciphertext), decipher.final()]).toString("hex");
  }
  extendedPrivateKey(password) {
    return _extended_key.ExtendedPrivateKey.parse(this.decrypt(password));
  }
  checkPassword(password) {
    const derivedKey = this.derivedKey(password);
    const ciphertext = Buffer.from(this.crypto.ciphertext, "hex");
    return Keystore.mac(derivedKey, ciphertext) === this.crypto.mac;
  }
  derivedKey(password) {
    const {
      kdfparams
    } = this.crypto;
    return Buffer.from((0, _scryptJs.syncScrypt)(Buffer.from(password), Buffer.from(kdfparams.salt, "hex"), kdfparams.n, kdfparams.r, kdfparams.p, kdfparams.dklen));
  }
  static mac(derivedKey, ciphertext) {
    return new _sha.Keccak(256).update(Buffer.concat([derivedKey.slice(16, 32), ciphertext])).digest("hex");
  }
  static scryptOptions(kdfparams) {
    return {
      N: kdfparams.n,
      r: kdfparams.r,
      p: kdfparams.p,
      maxmem: 128 * (kdfparams.n + kdfparams.p + 2) * kdfparams.r
    };
  }
}
exports.default = Keystore;
//# sourceMappingURL=keystore.js.map