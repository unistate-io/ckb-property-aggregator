"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ResultFormatter = exports.RPC = exports.ParamsFormatter = exports.CKBRPC = void 0;
var _Base = require("./Base");
var _method = require("./method");
var _paramsFormatter2 = require("./paramsFormatter");
var resultFormatter = _interopRequireWildcard(require("./resultFormatter"));
var _exceptions = require("./exceptions");
var _crossFetch = _interopRequireDefault(require("cross-fetch"));
var _abortController = _interopRequireDefault(require("abort-controller"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }
function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }
function _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }
function _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError("attempted to set read only private field"); } descriptor.value = value; } }
function _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }
function _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }
function _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }
const ParamsFormatter = _paramsFormatter2.formatter;
exports.ParamsFormatter = ParamsFormatter;
const ResultFormatter = resultFormatter;
exports.ResultFormatter = ResultFormatter;
var _config = /*#__PURE__*/new WeakMap();
var _node = /*#__PURE__*/new WeakMap();
var _paramsFormatter = /*#__PURE__*/new WeakMap();
var _resultFormatter = /*#__PURE__*/new WeakMap();
class CKBRPC extends _Base.Base {
  get node() {
    return _classPrivateFieldGet(this, _node);
  }
  get paramsFormatter() {
    return _classPrivateFieldGet(this, _paramsFormatter);
  }
  get resultFormatter() {
    return _classPrivateFieldGet(this, _resultFormatter);
  }
  constructor(url, _config2 = {}) {
    super();
    _classPrivateFieldInitSpec(this, _config, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _node, {
      writable: true,
      value: {
        url: ""
      }
    });
    _classPrivateFieldInitSpec(this, _paramsFormatter, {
      writable: true,
      value: _paramsFormatter2.formatter
    });
    _classPrivateFieldInitSpec(this, _resultFormatter, {
      writable: true,
      value: resultFormatter
    });
    _defineProperty(this, "addMethod", (options, config) => {
      const method = new _method.Method(this.node, options, config);
      Object.defineProperty(this, options.name, {
        value: method.call,
        enumerable: true
      });
    });
    /* eslint-disable */
    _defineProperty(this, "createBatchRequest", (
    // TODO fix me
    // params: [method: N, ...rest: P][] = [],
    params = []) => {
      const ctx = this;

      // TODO fix me
      const proxied = new Proxy([], {
        set(...p) {
          const methods = Object.keys(ctx);
          if (p[1] !== "length") {
            var _p$;
            const name = p === null || p === void 0 ? void 0 : (_p$ = p[2]) === null || _p$ === void 0 ? void 0 : _p$[0];
            if (methods.indexOf(name) === -1) {
              throw new _exceptions.MethodInBatchNotFoundException(name);
            }
          }
          return Reflect.set(...p);
        }
      });
      Object.defineProperties(proxied, {
        add: {
          value(...args) {
            this.push(args);
            return this;
          }
        },
        remove: {
          value(i) {
            this.splice(i, 1);
            return this;
          }
        },
        exec: {
          async value() {
            // TODO fix me
            const payload = proxied.map(([f, ...p], i) => {
              try {
                const method = new _method.Method(ctx.node, {
                  ...ctx.rpcProperties[f],
                  name: f
                });
                return method.getPayload(...p);
              } catch (err) {
                throw new _exceptions.PayloadInBatchException(i, err.message);
              }
            });
            const controller = new _abortController.default();
            const signal = controller.signal;
            const timeout = setTimeout(() => controller.abort(), _classPrivateFieldGet(ctx, _config).timeout);
            const batchRes = await _classPrivateFieldGet(ctx, _config).fetch(_classPrivateFieldGet(ctx, _node).url, {
              method: "POST",
              headers: {
                "content-type": "application/json"
              },
              body: JSON.stringify(payload),
              signal
            }).then(res => res.json());
            clearTimeout(timeout);
            return batchRes.map((res, i) => {
              var _ctx$rpcProperties$pr, _ctx$rpcProperties$pr2, _ctx$rpcProperties$pr3;
              if (res.id !== payload[i].id) {
                return new _exceptions.IdNotMatchedInBatchException(i, payload[i].id, res.id);
              }
              return (_ctx$rpcProperties$pr = (_ctx$rpcProperties$pr2 = (_ctx$rpcProperties$pr3 = ctx.rpcProperties[proxied[i][0]]).resultFormatters) === null || _ctx$rpcProperties$pr2 === void 0 ? void 0 : _ctx$rpcProperties$pr2.call(_ctx$rpcProperties$pr3, res.result)) !== null && _ctx$rpcProperties$pr !== void 0 ? _ctx$rpcProperties$pr : res.result;
            });
          }
        }
      });
      // TODO fix me
      params.forEach(p => proxied.push(p));
      return proxied;
    });
    this.setNode({
      url
    });
    const {
      timeout: _timeout = 30000,
      fetch = _crossFetch.default
    } = _config2;
    _classPrivateFieldSet(this, _config, {
      timeout: _timeout,
      fetch
    });
    Object.defineProperties(this, {
      addMethod: {
        value: this.addMethod,
        enumerable: false,
        writable: false,
        configurable: false
      },
      setNode: {
        value: this.setNode,
        enumerable: false,
        writable: false,
        configurable: false
      }
      // createBatchRequest: { value: this.createBatchRequest, enumerable: false, writable: false, configurable: false },
    });

    Object.keys(this.rpcProperties).forEach(name => {
      this.addMethod({
        name,
        ...this.rpcProperties[name]
      }, _classPrivateFieldGet(this, _config));
    });
  }
  setNode(node) {
    Object.assign(this.node, node);
    return this.node;
  }
}
exports.RPC = exports.CKBRPC = CKBRPC;
//# sourceMappingURL=index.js.map