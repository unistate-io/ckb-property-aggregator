"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toBannedAddresses = exports.toBannedAddress = exports.toArray = exports.toAlertMessage = void 0;
exports.toBlock = toBlock;
exports.toHash = exports.toGetTransactionsResult = exports.toGetCellsResult = exports.toForkBlockResult = exports.toFeeRateStatistics = exports.toFeeRate = exports.toEstimateCycles = exports.toEpoch = exports.toDeploymentsInfo = exports.toDeploymentInfo = exports.toDeployment = exports.toDeployState = exports.toDepType = exports.toConsensus = exports.toCellsIncludingOutPoint = exports.toCellsCapacity = exports.toCells = exports.toCellbaseOutputCapacityDetails = exports.toCellIncludingOutPoint = exports.toCellDep = exports.toCell = exports.toCapacityByLockHash = exports.toBlockchainInfo = exports.toBlockFilter = exports.toBlockEconomicState = void 0;
exports.toHeader = toHeader;
exports.toTip = exports.toSyncState = exports.toScript = exports.toRemoteNodeInfo = exports.toRawTxPool = exports.toPeers = exports.toOutput = exports.toOutPoint = exports.toNumber = exports.toNullable = exports.toLockHashIndexStates = exports.toLockHashIndexState = exports.toLocalNodeInfo = exports.toLiveCellsByLockHash = exports.toLiveCellWithStatus = exports.toLiveCell = exports.toInput = void 0;
exports.toTransaction = toTransaction;
exports.toUncleBlock = exports.toTxPoolInfo = exports.toTransactionsByLockHash = exports.toTransactionWithStatus = exports.toTransactionProof = exports.toTransactionPoint = exports.toTransactionAndWitnessProof = void 0;
/* eslint-disable camelcase, @typescript-eslint/no-explicit-any */

const isTxPoolIds = rawTxPool => {
  return Array.isArray(rawTxPool.pending);
};
const toArray = format => arg => {
  if (typeof format !== "function" || !Array.isArray(arg)) {
    return arg;
  }
  return arg.map(format);
};
exports.toArray = toArray;
const toNullable = format => origin => {
  if (!format || origin === null) return origin;
  return format(origin);
};
exports.toNullable = toNullable;
const toNumber = number => number.toString();
exports.toNumber = toNumber;
const toHash = hash => hash;
exports.toHash = toHash;
function toHeader(header) {
  if (typeof header === "string") return header;
  if (!header) return header;
  const {
    compact_target: compactTarget,
    transactions_root: transactionsRoot,
    proposals_hash: proposalsHash,
    extra_hash: extraHash,
    parent_hash: parentHash,
    ...rest
  } = header;
  return {
    compactTarget,
    parentHash,
    transactionsRoot,
    proposalsHash,
    extraHash,
    ...rest
  };
}
const toScript = script => {
  if (!script) return script;
  const {
    code_hash: codeHash,
    hash_type: hashType,
    ...rest
  } = script;
  return {
    codeHash,
    hashType,
    ...rest
  };
};
exports.toScript = toScript;
const toInput = input => {
  if (!input) return input;
  const {
    previous_output: previousOutput,
    ...rest
  } = input;
  return {
    previousOutput: previousOutput ? toOutPoint(previousOutput) : previousOutput,
    ...rest
  };
};
exports.toInput = toInput;
const toOutput = output => {
  if (!output) return output;
  const {
    lock,
    type,
    ...rest
  } = output;
  return {
    lock: toScript(lock),
    type: type ? toScript(type) : type,
    ...rest
  };
};
exports.toOutput = toOutput;
const toOutPoint = outPoint => {
  const {
    tx_hash: txHash,
    ...rest
  } = outPoint;
  return {
    txHash,
    ...rest
  };
};
exports.toOutPoint = toOutPoint;
const toDepType = type => {
  if (type === "dep_group") {
    return "depGroup";
  }
  return type;
};
exports.toDepType = toDepType;
const toCellDep = cellDep => {
  if (!cellDep) return cellDep;
  const {
    out_point: outPoint,
    dep_type = "code",
    ...rest
  } = cellDep;
  return {
    outPoint: toOutPoint(outPoint),
    depType: toDepType(dep_type),
    ...rest
  };
};
exports.toCellDep = toCellDep;
function toTransaction(tx) {
  if (!tx || typeof tx !== "object") return tx;
  const {
    cell_deps: cellDeps = [],
    inputs = [],
    outputs = [],
    outputs_data: outputsData = [],
    header_deps: headerDeps = [],
    ...rest
  } = tx;
  return {
    cellDeps: cellDeps.map(toCellDep),
    inputs: inputs.map(toInput),
    outputs: outputs.map(toOutput),
    outputsData,
    headerDeps,
    ...rest
  };
}
const toUncleBlock = uncleBlock => {
  if (!uncleBlock) return uncleBlock;
  const {
    header,
    ...rest
  } = uncleBlock;
  return {
    header: toHeader(header),
    ...rest
  };
};
exports.toUncleBlock = toUncleBlock;
const toTip = tip => ({
  blockHash: tip.block_hash,
  blockNumber: tip.block_number
});
exports.toTip = toTip;
function toBlock(res) {
  if (!res) return res;
  if (typeof res === "string") return res;
  if ("block" in res && "cycles" in res) {
    return {
      cycles: res.cycles,
      block: toBlock(res.block)
    };
  }
  const {
    header,
    uncles = [],
    transactions = [],
    ...rest
  } = res;
  return {
    header: toHeader(header),
    uncles: uncles.map(toUncleBlock),
    transactions: transactions.map(toTransaction),
    ...rest
  };
}
const toAlertMessage = alertMessage => {
  if (!alertMessage) return alertMessage;
  const {
    notice_until: noticeUntil,
    ...rest
  } = alertMessage;
  return {
    noticeUntil,
    ...rest
  };
};
exports.toAlertMessage = toAlertMessage;
const toBlockchainInfo = info => {
  if (!info) return info;
  const {
    is_initial_block_download: isInitialBlockDownload,
    median_time: medianTime,
    alerts,
    ...rest
  } = info;
  return {
    isInitialBlockDownload,
    medianTime,
    alerts: alerts.map(toAlertMessage),
    ...rest
  };
};
exports.toBlockchainInfo = toBlockchainInfo;
const toLocalNodeInfo = info => {
  if (!info) return info;
  const {
    node_id: nodeId,
    protocols,
    ...rest
  } = info;
  return {
    nodeId,
    protocols: protocols.map(({
      id,
      name,
      support_versions: supportVersions
    }) => ({
      id,
      name,
      supportVersions
    })),
    ...rest
  };
};
exports.toLocalNodeInfo = toLocalNodeInfo;
const toRemoteNodeInfo = info => {
  if (!info) return info;
  const {
    node_id: nodeId,
    connected_duration: connectedDuration,
    is_outbound: isOutbound,
    last_ping_duration: lastPingDuration,
    sync_state,
    ...rest
  } = info;
  return {
    nodeId,
    connectedDuration,
    isOutbound,
    lastPingDuration,
    syncState: {
      bestKnownHeaderHash: sync_state.best_known_header_hash,
      bestKnownHeaderNumber: sync_state.best_known_header_number,
      canFetchCount: sync_state.can_fetch_count,
      inflightCount: sync_state.inflight_count,
      lastCommonHeaderHash: sync_state.last_common_header_hash,
      lastCommonHeaderNumber: sync_state.last_common_header_number,
      unknownHeaderListSize: sync_state.unknown_header_list_size
    },
    ...rest
  };
};
exports.toRemoteNodeInfo = toRemoteNodeInfo;
const toTxPoolInfo = info => {
  if (!info) return info;
  const {
    last_txs_updated_at: lastTxsUpdatedAt,
    tip_hash: tipHash,
    tip_number: tipNumber,
    total_tx_cycles: totalTxCycles,
    total_tx_size: totalTxSize,
    min_fee_rate: minFeeRate,
    ...rest
  } = info;
  return {
    lastTxsUpdatedAt,
    tipHash,
    tipNumber,
    totalTxCycles,
    totalTxSize,
    minFeeRate,
    ...rest
  };
};
exports.toTxPoolInfo = toTxPoolInfo;
const toPeers = nodes => {
  if (!Array.isArray(nodes)) return [];
  return nodes.map(toRemoteNodeInfo);
};
exports.toPeers = toPeers;
const toCell = cell => {
  if (!cell) return cell;
  const {
    lock,
    type,
    ...rest
  } = cell;
  return {
    lock: toScript(lock),
    type: type ? toScript(type) : undefined,
    ...rest
  };
};
exports.toCell = toCell;
const toLiveCell = liveCell => {
  if (!liveCell) return liveCell;
  const {
    data,
    output,
    ...rest
  } = liveCell;
  return {
    data,
    output: toOutput(output),
    ...rest
  };
};
exports.toLiveCell = toLiveCell;
const toLiveCellWithStatus = cellWithStatus => {
  if (!cellWithStatus) return cellWithStatus;
  const {
    cell,
    ...rest
  } = cellWithStatus;
  return {
    cell: toLiveCell(cell),
    ...rest
  };
};
exports.toLiveCellWithStatus = toLiveCellWithStatus;
const toCells = cells => {
  if (!Array.isArray(cells)) return [];
  return cells.map(toCell);
};
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
exports.toCells = toCells;
const toCellIncludingOutPoint = cell => {
  if (!cell) return cell;
  const {
    lock,
    block_hash: blockHash,
    out_point,
    output_data_len: outputDataLen,
    ...rest
  } = cell;
  return {
    blockHash,
    lock: toScript(lock),
    outPoint: toOutPoint(out_point),
    outputDataLen,
    ...rest
  };
};
exports.toCellIncludingOutPoint = toCellIncludingOutPoint;
const toCellsIncludingOutPoint = cells => {
  if (!Array.isArray(cells)) return [];
  return cells.map(toCellIncludingOutPoint);
};
exports.toCellsIncludingOutPoint = toCellsIncludingOutPoint;
const toTransactionWithStatus = txWithStatus => {
  if (!txWithStatus) return txWithStatus;
  const {
    transaction,
    tx_status: {
      block_hash: blockHash,
      status
    },
    time_added_to_pool,
    ...rest
  } = txWithStatus;
  return {
    transaction: toTransaction(transaction),
    txStatus: {
      blockHash,
      status,
      ...("reason" in txWithStatus.tx_status ? {
        reason: txWithStatus.tx_status.reason
      } : {})
    },
    timeAddedToPool: time_added_to_pool,
    ...rest
  };
};
exports.toTransactionWithStatus = toTransactionWithStatus;
const toEpoch = epoch => {
  if (!epoch) return epoch;
  const {
    start_number: startNumber,
    compact_target: compactTarget,
    ...rest
  } = epoch;
  return {
    compactTarget,
    startNumber,
    ...rest
  };
};
exports.toEpoch = toEpoch;
const toTransactionPoint = transactionPoint => {
  if (!transactionPoint) return transactionPoint;
  const {
    block_number: blockNumber,
    tx_hash: txHash,
    ...rest
  } = transactionPoint;
  return {
    blockNumber,
    txHash,
    ...rest
  };
};
exports.toTransactionPoint = toTransactionPoint;
const toTransactionsByLockHash = transactions => {
  if (!transactions) return transactions;
  return transactions.map(tx => ({
    consumedBy: tx.consumed_by ? toTransactionPoint(tx.consumed_by) : tx.consumed_by,
    createdBy: toTransactionPoint(tx.created_by)
  }));
};
exports.toTransactionsByLockHash = toTransactionsByLockHash;
const toLiveCellsByLockHash = cells => {
  if (!cells) return cells;
  return cells.map(cell => ({
    cellOutput: toCell(cell.cell_output),
    createdBy: toTransactionPoint(cell.created_by),
    cellbase: cell.cellbase,
    outputDataLen: cell.output_data_len
  }));
};
exports.toLiveCellsByLockHash = toLiveCellsByLockHash;
const toLockHashIndexState = index => {
  if (!index) return index;
  const {
    block_hash: blockHash,
    block_number: blockNumber,
    lock_hash: lockHash,
    ...rest
  } = index;
  return {
    blockHash,
    blockNumber,
    lockHash,
    ...rest
  };
};
exports.toLockHashIndexState = toLockHashIndexState;
const toLockHashIndexStates = states => {
  if (!states) return states;
  return states.map(toLockHashIndexState);
};
exports.toLockHashIndexStates = toLockHashIndexStates;
const toBannedAddress = bannedAddress => {
  if (!bannedAddress) return bannedAddress;
  const {
    ban_reason: banReason,
    ban_until: banUntil,
    created_at: createdAt,
    ...rest
  } = bannedAddress;
  return {
    banReason,
    banUntil,
    createdAt,
    ...rest
  };
};
exports.toBannedAddress = toBannedAddress;
const toBannedAddresses = bannedAddresses => {
  if (!bannedAddresses) return bannedAddresses;
  return bannedAddresses.map(banAddr => toBannedAddress(banAddr));
};
exports.toBannedAddresses = toBannedAddresses;
const toCellbaseOutputCapacityDetails = details => {
  if (!details) return details;
  const {
    proposal_reward: proposalReward,
    tx_fee: txFee,
    ...rest
  } = details;
  return {
    proposalReward,
    txFee,
    ...rest
  };
};
exports.toCellbaseOutputCapacityDetails = toCellbaseOutputCapacityDetails;
const toFeeRate = feeRateObj => {
  if (!feeRateObj) {
    return feeRateObj;
  }
  const {
    fee_rate: feeRate,
    ...rest
  } = feeRateObj;
  return {
    feeRate,
    ...rest
  };
};
exports.toFeeRate = toFeeRate;
const toCapacityByLockHash = capacityByLockHash => {
  if (!capacityByLockHash) {
    return capacityByLockHash;
  }
  const {
    cells_count: cellsCount,
    block_number: blockNumber,
    capacity,
    ...rest
  } = capacityByLockHash;
  return {
    blockNumber,
    capacity,
    cellsCount,
    ...rest
  };
};
exports.toCapacityByLockHash = toCapacityByLockHash;
const toBlockEconomicState = blockEconomicState => {
  if (!blockEconomicState) {
    return blockEconomicState;
  }
  const {
    finalized_at: finalizedAt,
    miner_reward: minerReward,
    txs_fee: txsFee,
    ...rest
  } = blockEconomicState;
  return {
    finalizedAt,
    minerReward,
    txsFee,
    ...rest
  };
};
exports.toBlockEconomicState = toBlockEconomicState;
const toSyncState = state => {
  if (!state) {
    return state;
  }
  return {
    bestKnownBlockNumber: state.best_known_block_number,
    bestKnownBlockTimestamp: state.best_known_block_timestamp,
    fastTime: state.fast_time,
    ibd: state.ibd,
    inflightBlocksCount: state.inflight_blocks_count,
    lowTime: state.low_time,
    normalTime: state.normal_time,
    orphanBlocksCount: state.orphan_blocks_count
  };
};
exports.toSyncState = toSyncState;
const toTransactionProof = proof => {
  if (!proof) {
    return proof;
  }
  const {
    block_hash: blockHash,
    witnesses_root: witnessesRoot,
    ...rest
  } = proof;
  return {
    blockHash,
    witnessesRoot,
    ...rest
  };
};
exports.toTransactionProof = toTransactionProof;
const toHardforkFeature = feature => {
  return {
    rfc: feature.rfc,
    epochNumber: feature.epoch_number
  };
};
const toDeployment = deployment => {
  return {
    bit: deployment.bit,
    start: deployment.start,
    timeout: deployment.timeout,
    minActivationEpoch: deployment.min_activation_epoch,
    period: deployment.period,
    threshold: deployment.threshold
  };
};
exports.toDeployment = toDeployment;
const toSoftFork = softFork => {
  if ("rfc0043" in softFork) {
    return {
      status: softFork.status,
      rfc0043: toDeployment(softFork.rfc0043)
    };
  }
  return softFork;
};
const toConsensus = consensus => {
  if (!consensus) return consensus;
  const rpcHardforkFeatures = consensus.hardfork_features;
  const softforks = consensus.softforks;
  const lightClient = softforks.light_client && toSoftFork(softforks.light_client);
  const testdummy = softforks.testdummy && toSoftFork(softforks.testdummy);
  return {
    blockVersion: consensus.block_version,
    cellbaseMaturity: consensus.cellbase_maturity,
    daoTypeHash: consensus.dao_type_hash,
    epochDurationTarget: consensus.epoch_duration_target,
    genesisHash: consensus.genesis_hash,
    id: consensus.id,
    initialPrimaryEpochReward: consensus.initial_primary_epoch_reward,
    maxBlockBytes: consensus.max_block_bytes,
    maxBlockCycles: consensus.max_block_cycles,
    maxBlockProposalsLimit: consensus.max_block_proposals_limit,
    maxUnclesNum: consensus.max_uncles_num,
    medianTimeBlockCount: consensus.median_time_block_count,
    orphanRateTarget: consensus.orphan_rate_target,
    permanentDifficultyInDummy: consensus.permanent_difficulty_in_dummy,
    primaryEpochRewardHalvingInterval: consensus.primary_epoch_reward_halving_interval,
    proposerRewardRatio: consensus.proposer_reward_ratio,
    secondaryEpochReward: consensus.secondary_epoch_reward,
    secp256k1Blake160MultisigAllTypeHash: consensus.secp256k1_blake160_multisig_all_type_hash,
    secp256k1Blake160SighashAllTypeHash: consensus.secp256k1_blake160_sighash_all_type_hash,
    txProposalWindow: consensus.tx_proposal_window,
    txVersion: consensus.tx_version,
    typeIdCodeHash: consensus.type_id_code_hash,
    hardforkFeatures: rpcHardforkFeatures.map(toHardforkFeature),
    softforks: {
      ...(lightClient && {
        lightClient
      }),
      ...(testdummy && {
        testdummy
      })
    }
  };
};
exports.toConsensus = toConsensus;
const toRawTxPool = rawTxPool => {
  if (!rawTxPool) return rawTxPool;
  if (isTxPoolIds(rawTxPool)) {
    return rawTxPool;
  }
  const toTxVerbosity = ({
    ancestors_count: ancestorsCount,
    ancestors_cycles: ancestorsCycles,
    ancestors_size: ancestorsSize,
    ...rest
  }) => ({
    ancestorsCount,
    ancestorsCycles,
    ancestorsSize,
    ...rest
  });
  const proposed = {};
  const pending = {};
  Object.keys(rawTxPool.proposed).forEach(hash => {
    proposed[hash] = toTxVerbosity(rawTxPool.proposed[hash]);
  });
  Object.keys(rawTxPool.pending).forEach(hash => {
    pending[hash] = toTxVerbosity(rawTxPool.pending[hash]);
  });
  return {
    proposed,
    pending
  };
};
exports.toRawTxPool = toRawTxPool;
const toIndexerCell = indexerCell => {
  if (!indexerCell) return indexerCell;
  return {
    blockNumber: indexerCell.block_number,
    outPoint: toOutPoint(indexerCell.out_point),
    output: toOutput(indexerCell.output),
    outputData: indexerCell.output_data,
    txIndex: indexerCell.tx_index
  };
};
const toGetCellsResult = getCellsResult => ({
  lastCursor: getCellsResult.last_cursor,
  objects: getCellsResult.objects.map(object => toIndexerCell(object))
});
exports.toGetCellsResult = toGetCellsResult;
const isUngroupedIndexerTransaction = value => {
  if (value.cells) {
    return false;
  }
  return true;
};
const toIndexerTransaction = indexerTransaction => {
  if (!indexerTransaction) return indexerTransaction;
  if (isUngroupedIndexerTransaction(indexerTransaction)) {
    return {
      txHash: indexerTransaction.tx_hash,
      blockNumber: indexerTransaction.block_number,
      ioIndex: indexerTransaction.io_index,
      ioType: indexerTransaction.io_type,
      txIndex: indexerTransaction.tx_index
    };
  }
  return {
    txHash: indexerTransaction.tx_hash,
    txIndex: indexerTransaction.tx_index,
    blockNumber: indexerTransaction.block_number,
    cells: indexerTransaction.cells
  };
};
const toGetTransactionsResult = getTransactionsResult => {
  if (!getTransactionsResult) return getTransactionsResult;
  return {
    lastCursor: getTransactionsResult.last_cursor,
    objects: getTransactionsResult.objects.map(object => toIndexerTransaction(object))
  };
};
exports.toGetTransactionsResult = toGetTransactionsResult;
const toCellsCapacity = cellsCapacity => {
  if (!cellsCapacity) return cellsCapacity;
  return {
    capacity: cellsCapacity.capacity,
    blockHash: cellsCapacity.block_hash,
    blockNumber: cellsCapacity.block_number
  };
};
exports.toCellsCapacity = toCellsCapacity;
const toBlockFilter = blockFilter => {
  return {
    hash: blockFilter.hash,
    data: blockFilter.data
  };
};
exports.toBlockFilter = toBlockFilter;
const toTransactionAndWitnessProof = proof => {
  return {
    blockHash: proof.block_hash,
    transactionsProof: proof.transactions_proof,
    witnessesProof: proof.witnesses_proof
  };
};
exports.toTransactionAndWitnessProof = toTransactionAndWitnessProof;
const toFeeRateStatistics = statistics => {
  return {
    mean: statistics.mean,
    median: statistics.median
  };
};
exports.toFeeRateStatistics = toFeeRateStatistics;
const toForkBlockResult = result => {
  if (typeof result === "string") {
    return result;
  }
  return {
    header: toHeader(result.header),
    uncles: result.uncles.map(toUncleBlock),
    transactions: result.transactions.map(toTransaction),
    proposals: result.proposals,
    extension: result.extension
  };
};
exports.toForkBlockResult = toForkBlockResult;
const toEstimateCycles = cycle => {
  return {
    cycles: cycle.cycles
  };
};
exports.toEstimateCycles = toEstimateCycles;
const toDeployState = state => {
  if (state === "locked_in") {
    return "lockedIn";
  }
  return state;
};
exports.toDeployState = toDeployState;
const toDeploymentInfo = deploymentInfo => {
  return {
    bit: deploymentInfo.bit,
    /// specifies the first epoch in which the bit gains meaning.
    start: deploymentInfo.start,
    timeout: deploymentInfo.timeout,
    minActivationEpoch: deploymentInfo.min_activation_epoch,
    period: deploymentInfo.period,
    threshold: deploymentInfo.threshold,
    since: deploymentInfo.since,
    state: toDeployState(deploymentInfo.state)
  };
};
exports.toDeploymentInfo = toDeploymentInfo;
const toDeploymentsInfo = deploymentInfo => {
  const {
    light_client,
    testdummy
  } = deploymentInfo.deployments;
  return {
    hash: deploymentInfo.hash,
    epoch: deploymentInfo.epoch,
    deployments: {
      ...(light_client ? {
        lightClient: toDeploymentInfo(light_client)
      } : {}),
      ...(testdummy ? {
        testdummy: toDeploymentInfo(testdummy)
      } : {})
    }
  };
};

/* eslint-enable camelcase */
exports.toDeploymentsInfo = toDeploymentsInfo;
//# sourceMappingURL=resultFormatter.js.map